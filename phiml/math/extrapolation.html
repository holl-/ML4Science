<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>phiml.math.extrapolation API documentation</title>
<meta name="description" content="Extrapolations are used for padding tensors and sampling coordinates lying outside the tensor bounds.
Standard extrapolations are listed as global â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phiml.math.extrapolation</code></h1>
</header>
<section id="section-intro">
<p>Extrapolations are used for padding tensors and sampling coordinates lying outside the tensor bounds.
Standard extrapolations are listed as global variables in this module.</p>
<p>Extrapolations are an important part of sampled fields such as grids.
See the documentation at <a href="https://tum-pbs.github.io/PhiML/Fields.html#extrapolations">https://tum-pbs.github.io/PhiML/Fields.html#extrapolations</a> .</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Extrapolations are used for padding tensors and sampling coordinates lying outside the tensor bounds.
Standard extrapolations are listed as global variables in this module.

Extrapolations are an important part of sampled fields such as grids.
See the documentation at https://tum-pbs.github.io/PhiML/Fields.html#extrapolations .
&#34;&#34;&#34;
import warnings
from numbers import Number
from typing import Union, Dict, Callable, Tuple, Optional, Hashable, Sequence

from ..backend._backend import get_spatial_derivative_order
from ..backend import choose_backend
from ._shape import Shape, channel, spatial, EMPTY_SHAPE, merge_shapes, dual, non_dual, instance
from ._magic_ops import concat, stack, expand, rename_dims
from ._tensors import Tensor, NativeTensor, TensorStack, wrap
from . import _ops as math  # TODO this executes _ops.py, can we avoid this?


class Extrapolation:
    &#34;&#34;&#34;
    Extrapolations are used to determine values of grids or other structures outside the sampled bounds.
    They play a vital role in padding and sampling.
    &#34;&#34;&#34;

    def __init__(self, pad_rank):
        &#34;&#34;&#34;
        Args:
            pad_rank: low-ranking extrapolations are handled first during mixed-extrapolation padding.
                The typical order is periodic=1, boundary=2, symmetric=3, reflect=4, constant=5.
        &#34;&#34;&#34;
        self.pad_rank = pad_rank

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        Serialize this extrapolation to a dictionary that is serializable (JSON-writable).
        
        Use `from_dict()` to restore the Extrapolation object.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def spatial_gradient(self) -&gt; &#39;Extrapolation&#39;:
        &#34;&#34;&#34;
        Returns the extrapolation for the spatial gradient of a tensor/field with this extrapolation.

        Returns:
            `Extrapolation` or `NotImplemented`
        &#34;&#34;&#34;
        raise NotImplementedError()

    def valid_outer_faces(self, dim) -&gt; Tuple[bool, bool]:
        &#34;&#34;&#34;
        Use `determines_boundary_values()` instead.

         `(lower: bool, upper: bool)` indicating whether the values sampled at the outer-most faces of a staggered grid with this extrapolation are valid, i.e. need to be stored and are not redundant. &#34;&#34;&#34;
        return not self.determines_boundary_values((dim, False)), not self.determines_boundary_values((dim, True))

    def determines_boundary_values(self, boundary_key: Union[Tuple[str, bool], str]) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether this extrapolation fully determines the values at the boundary faces of the outermost cells or elements.
        If so, the values need not be stored along with the inside values.

        Override this function instead of `valid_outer_faces()`.

        Args:
            boundary_key: Hashable object identifying the boundary, e.g. a `str` or `Tuple`.

        Returns:
            Whether the value is fully determined by the boundary and need not be stored elsewhere.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @property
    def is_flexible(self) -&gt; bool:
        &#34;&#34;&#34;
        Whether the outside values are affected by the inside values.
        Only `True` if there are actual outside values, i.e. PERIODIC is not flexible.

        This property is important for pressure solves to determine whether the total divergence is fixed or can be adjusted during the solve.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def pad(self, value: Tensor, widths: dict, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        &#34;&#34;&#34;
        Pads a tensor using values from `self.pad_values()`.

        If `value` is a linear tracer, assume pad_values() to produce constant values, independent of `value`.
        To change this behavior, override this method.

        Args:
            value: `Tensor` to be padded
            widths: `dict` mapping `dim: str -&gt; (lower: int, upper: int)`
            already_padded: Used when padding a tensor with multiple extrapolations.
                Contains all widths that have already been padded prior to this call.
                This causes the shape of `value` to be different from the original tensor passed to `math.pad()`.
            kwargs: Additional keyword arguments for padding, passed on to `pad_values()`.

        Returns:
            Padded `Tensor`
        &#34;&#34;&#34;
        from ._trace import ShiftLinTracer
        if isinstance(value, ShiftLinTracer):
            lower = {dim: -lo for dim, (lo, _) in widths.items()}
            return value.shift(lower, new_shape=value.shape.after_pad(widths), val_fun=lambda v: ZERO.pad(v, widths, already_padded=already_padded, **kwargs), bias_fun=lambda b: self.pad(b, widths, already_padded=already_padded, **kwargs))
        already_padded = {} if already_padded is None else dict(already_padded)
        for dim, width in widths.items():
            assert (w &gt; 0 for w in width), &#34;Negative widths not allowed in Extrapolation.pad(). Use math.pad() instead.&#34;
            values = []
            if width[False] &gt; 0:
                values.append(self.pad_values(value, width[False], dim, False, already_padded=already_padded, **kwargs))
            values.append(value)
            if width[True] &gt; 0:
                values.append(self.pad_values(value, width[True], dim, True, already_padded=already_padded, **kwargs))
            value = concat(values, dim)
            if dim in already_padded:
                already_padded[dim] = tuple(i+j for i, j in zip(already_padded[dim], width))
            else:
                already_padded[dim] = width
        return value

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        &#34;&#34;&#34;
        Determines the values with which the given tensor would be padded at the specified using this extrapolation.

        Args:
            value: `Tensor` to be padded.
            width: `int &gt; 0`: Number of cells to pad along `dimension`.
            dim: Dimension name as `str`.
            upper_edge: `True` for upper edge, `False` for lower edge.
            already_padded: Used when padding a tensor with multiple extrapolations.
                Contains all widths that have already been padded prior to this call.
                This causes the shape of `value` to be different from the original tensor passed to `math.pad()`.

        Returns:
            `Tensor` that can be concatenated to `value` along `dimension`
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def sparse_pad_values(self, value: Tensor, connectivity: Tensor, dim: str, upper_edge: bool, **kwargs) -&gt; Tensor:
        raise NotImplementedError(self.__class__)

    def transform_coordinates(self, coordinates: Tensor, shape: Shape, **kwargs) -&gt; Tensor:
        &#34;&#34;&#34;
        If `self.is_copy_pad`, transforms outside coordinates to the index from which the value is copied.
        
        Otherwise, the grid tensor is assumed to hold the correct boundary values for this extrapolation at the edge.
        Coordinates are then snapped to the valid index range.
        This is the default implementation.

        Args:
            coordinates: integer coordinates in index space
            shape: tensor shape

        Returns:
            Transformed coordinates
        &#34;&#34;&#34;
        res = shape.spatial[coordinates.shape.get_item_names(&#39;vector&#39;)] if &#39;vector&#39; in coordinates.shape and coordinates.shape.get_item_names(&#39;vector&#39;) else shape.spatial
        return math.clip(coordinates, 0, math.wrap(res - 1, channel(&#39;vector&#39;)))

    def is_copy_pad(self, dim: str, upper_edge: bool):
        &#34;&#34;&#34;:return: True if all pad values are copies of existing values in the tensor to be padded&#34;&#34;&#34;
        return False

    @property
    def native_grid_sample_mode(self) -&gt; Union[str, None]:
        return None

    def shortest_distance(self, start: Tensor, end: Tensor, domain_size: Tensor):
        &#34;&#34;&#34;
        Computes the shortest distance between two points.
        Both points are assumed to lie within the domain

        Args:
            start: Start position.
            end: End position.
            domain_size: Domain side lengths as vector.

        Returns:
            Shortest distance from `start` to `end`.
        &#34;&#34;&#34;
        return end - start

    def __getitem__(self, item):
        return self

    def _getitem_with_domain(self, item: dict, dim: str, upper_edge: bool, all_dims: Sequence[str]):
        return self[item]

    def __abs__(self):
        raise NotImplementedError(self.__class__)

    def __neg__(self):
        raise NotImplementedError(self.__class__)

    def __add__(self, other):
        raise NotImplementedError(self.__class__)

    def __radd__(self, other):
        raise NotImplementedError(self.__class__)

    def __sub__(self, other):
        raise NotImplementedError(self.__class__)

    def __rsub__(self, other):
        raise NotImplementedError(self.__class__)

    def __mul__(self, other):
        raise NotImplementedError(self.__class__)

    def __rmul__(self, other):
        raise NotImplementedError(self.__class__)

    def __truediv__(self, other):
        raise NotImplementedError(self.__class__)

    def __rtruediv__(self, other):
        raise NotImplementedError(self.__class__)


class ConstantExtrapolation(Extrapolation):
    &#34;&#34;&#34;
    Extrapolate with a constant value.
    &#34;&#34;&#34;

    def __init__(self, value: Union[Tensor, float]):
        Extrapolation.__init__(self, 5)
        self.value = wrap(value)
        &#34;&#34;&#34; Extrapolation value &#34;&#34;&#34;
        assert self.value.dtype.kind in (bool, int, float, complex), f&#34;Numeric value required for constant extrapolation but got &#39;{value}&#39;&#34;

    @property
    def shape(self):
        return self.value.shape

    def __repr__(self):
        return repr(self.value)

    def to_dict(self) -&gt; dict:
        return {&#39;type&#39;: &#39;constant&#39;, &#39;value&#39;: self.value.numpy()}

    def __value_attrs__(self):
        return &#39;value&#39;,

    def __getitem__(self, item):
        return ConstantExtrapolation(self.value[item])

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;ConstantExtrapolation&#39;:
        if all(isinstance(v, ConstantExtrapolation) for v in values):
            return ConstantExtrapolation(stack([v.value for v in values], dim, **kwargs))
        else:
            return NotImplemented

    def spatial_gradient(self):
        return ZERO

    def determines_boundary_values(self, boundary_key: Union[Tuple[str, bool], str]) -&gt; bool:
        return True

    @property
    def is_flexible(self) -&gt; bool:
        return False

    def pad(self, value: Tensor, widths: dict, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        &#34;&#34;&#34;Pads a tensor using constant values.&#34;&#34;&#34;
        value = value._simplify()
        if isinstance(value, NativeTensor):
            pad_value = self._get_pad_value(already_padded)
            backend = choose_backend(value._native, pad_value.native())
            for dim in pad_value.shape.non_batch.names:
                assert dim in value.shape, f&#34;Cannot pad tensor {value.shape} with extrapolation {pad_value.shape} because non-batch dimension &#39;{dim}&#39; is missing.&#34;
            if pad_value.rank == 0:
                equal_values = math.all_available(self.value, value) and value._native_shape in self.value.shape and (self.value == value).all
                if not equal_values:
                    required_dims = value._shape.only(tuple(widths.keys()))
                    value = value._cached(required_dims)
                should_pad_native = any(dim in value._native_shape for dim in widths) and pad_value.shape.volume == 1
                if should_pad_native:
                    ordered_pad_widths = order_by_shape(value._native_shape, widths, default=(0, 0))
                    result_native = backend.pad(value._native, ordered_pad_widths, &#39;constant&#39;, pad_value.native())
                else:
                    result_native = value._native
                if result_native is not NotImplemented:
                    return NativeTensor(result_native, value._native_shape.after_pad(widths), value._shape.after_pad(widths))
            return Extrapolation.pad(self, value, widths, already_padded=already_padded, **kwargs)
        elif isinstance(value, TensorStack):
            if not value.requires_broadcast:
                return self.pad(value._cache(), widths)
            inner_widths = {dim: w for dim, w in widths.items() if dim != value._stack_dim.name}
            tensors = [self[{value._stack_dim.name: i}].pad(t, inner_widths) for i, t in enumerate(value.dimension(value._stack_dim.name))]
            return TensorStack(tensors, value._stack_dim)
        else:
            return Extrapolation.pad(self, value, widths, already_padded=already_padded, **kwargs)

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        shape = value.shape.after_gather({dim: slice(0, width)})
        pad_value = self._get_pad_value(already_padded)
        return math.expand(pad_value, shape)

    def _get_pad_value(self, already_padded: Optional[dict]):
        if get_spatial_derivative_order() == 0:
            if already_padded:
                return ZERO.pad(self.value, already_padded)
            else:
                return self.value
        else:
            return math.wrap(0)

    def sparse_pad_values(self, value: Tensor, connectivity: Tensor, dim: str, upper_edge: bool, **kwargs) -&gt; Tensor:
        return math.expand(self.value, dual(connectivity) &amp; non_dual(value))

    def __eq__(self, other):
        return isinstance(other, ConstantExtrapolation) and math.always_close(self.value, other.value)

    def __hash__(self):
        return hash(self.__class__)

    def is_zero(self):
        return self == ZERO

    def is_one(self):
        return self == ONE

    @property
    def native_grid_sample_mode(self) -&gt; Union[str, None]:
        return &#39;zeros&#39; if self.is_zero() else None

    def __add__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value + other.value)
        elif self.is_zero():
            return other
        else:
            return NotImplemented

    __radd__ = __add__

    def __sub__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value - other.value)
        elif self.is_zero():
            return -other
        else:
            return NotImplemented

    def __rsub__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(other.value - self.value)
        elif self.is_zero():
            return other
        else:
            return NotImplemented

    def __mul__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value * other.value)
        elif self.is_one():
            return other
        elif self.is_zero():
            return self
        else:
            return NotImplemented

    __rmul__ = __mul__

    def __truediv__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value / other.value)
        elif self.is_zero():
            return self
        else:
            return NotImplemented

    def __rtruediv__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(other.value / self.value)
        elif self.is_one():
            return other
        else:
            return NotImplemented

    def __lt__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value &lt; other.value)
        else:
            return NotImplemented

    def __gt__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value &gt; other.value)
        else:
            return NotImplemented

    def __abs__(self):
        return ConstantExtrapolation(abs(self.value))

    def __neg__(self):
        return ConstantExtrapolation(-self.value)


class _CopyExtrapolation(Extrapolation):

    @property
    def shape(self):
        return EMPTY_SHAPE

    def is_copy_pad(self, dim: str, upper_edge: bool):
        return True

    def to_dict(self) -&gt; dict:
        return {&#39;type&#39;: repr(self)}

    @property
    def backend_pad_mode(self) -&gt; Optional[str]:
        return repr(self)

    @property
    def native_grid_sample_mode(self) -&gt; Union[str, None]:
        return str(self)

    def __value_attrs__(self):
        return ()

    def determines_boundary_values(self, boundary_key: Union[Tuple[str, bool], str]) -&gt; bool:
        return False

    @property
    def _is_dim_separable(self):
        &#34;&#34;&#34;
        If `True`, the extrapolation values only depend on values of the same row/column.
        If `False`, collapsed dimensions have to be expanded during padding.
        &#34;&#34;&#34;
        return True

    def pad(self, value: Tensor, widths: dict, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        value = value._simplify()
        from ._trace import ShiftLinTracer
        if isinstance(value, NativeTensor):
            if not self._is_dim_separable:
                required_dims = value._shape.only(tuple(widths.keys()))
                value = value._cached(required_dims)
            should_pad_native = any(dim in value._native_shape for dim in widths)
            if should_pad_native:
                ordered_pad_widths = order_by_shape(value._native_shape, widths, default=(0, 0))
                result_native = value.default_backend.pad(value._native, ordered_pad_widths, self.backend_pad_mode)
            else:
                result_native = value._native
            if result_native is not NotImplemented:
                return NativeTensor(result_native, value._native_shape.after_pad(widths), value._shape.after_pad(widths))
            return Extrapolation.pad(self, value, widths)
        elif isinstance(value, TensorStack):
            if not value.requires_broadcast:
                return self.pad(value._cache(), widths)
            inner_widths = {dim: w for dim, w in widths.items() if dim != value._stack_dim.name}
            tensors = [self.pad(t, inner_widths) for t in value.dimension(value._stack_dim.name)]
            return TensorStack(tensors, value._stack_dim)
        elif isinstance(value, ShiftLinTracer):
            return self._pad_linear_tracer(value, widths)
        else:
            raise NotImplementedError(f&#39;{type(value)} not supported&#39;)

    def _pad_linear_tracer(self, value, widths: dict):
        raise NotImplementedError()

    def __eq__(self, other):
        return type(other) == type(self)

    def __hash__(self):
        return hash(self.__class__)

    def _op(self, other, op):
        if type(other) == type(self):
            return self
        if isinstance(other, ConstantExtrapolation):  # some operations can be handled by ConstantExtrapolation, e.g. * 0
            op = getattr(other, op.__name__)
            return op(self)
        else:
            return NotImplemented

    def __abs__(self):
        return self  # assume also applied to values

    def __neg__(self):
        return self  # assume also applied to values

    def __add__(self, other):
        return self._op(other, ConstantExtrapolation.__add__)

    def __radd__(self, other):
        return self._op(other, ConstantExtrapolation.__add__)

    def __mul__(self, other):
        return self._op(other, ConstantExtrapolation.__mul__)

    def __rmul__(self, other):
        return self._op(other, ConstantExtrapolation.__mul__)

    def __sub__(self, other):
        return self._op(other, ConstantExtrapolation.__rsub__)

    def __rsub__(self, other):
        return self._op(other, ConstantExtrapolation.__sub__)

    def __truediv__(self, other):
        return self._op(other, ConstantExtrapolation.__rtruediv__)

    def __rtruediv__(self, other):
        return self._op(other, ConstantExtrapolation.__truediv__)

    def __lt__(self, other):
        return self._op(other, ConstantExtrapolation.__gt__)

    def __gt__(self, other):
        return self._op(other, ConstantExtrapolation.__lt__)


class _ZeroGradient(_CopyExtrapolation):
    &#34;&#34;&#34;Uses the closest defined value for points lying outside the defined region.&#34;&#34;&#34;

    _CACHED_LOWER_MASKS = {}
    _CACHED_UPPER_MASKS = {}

    def __repr__(self):
        return &#39;zero-gradient&#39;

    @property
    def backend_pad_mode(self) -&gt; Optional[str]:
        return &#39;boundary&#39;

    @property
    def native_grid_sample_mode(self) -&gt; Union[str, None]:
        return &#39;boundary&#39;

    def spatial_gradient(self):
        return ZERO

    @property
    def is_flexible(self) -&gt; bool:
        return True

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        if upper_edge:
            edge = value[{dim: slice(-1, None)}]
        else:
            edge = value[{dim: slice(1)}]
        return concat([edge] * width, value.shape[dim])

    def _pad_linear_tracer(self, value: &#39;ShiftLinTracer&#39;, widths: dict) -&gt; &#39;ShiftLinTracer&#39;:
        &#34;&#34;&#34;
        *Warning*:
        This implementation discards corners, i.e. values that lie outside the original tensor in more than one dimension.
        These are typically sliced off in differential operators. Corners are instead assigned the value 0.
        To take corners into account, call pad() for each axis individually. This is inefficient with ShiftLinTracer.

        Args:
          value: ShiftLinTracer:
          widths: dict: 

        Returns:

        &#34;&#34;&#34;
        lower = {dim: -lo for dim, (lo, _) in widths.items()}
        result = value.shift(lower, new_shape=value.shape.after_pad(widths), val_fun=lambda v: ZERO.pad(v, widths), bias_fun=lambda b: ZERO.pad(b, widths))  # inner values  ~half the computation time
        for bound_dim, (bound_lo, bound_hi) in widths.items():
            for i in range(bound_lo):  # i=0 means outer
                # this sets corners to 0
                lower = {dim: -i if dim == bound_dim else -lo for dim, (lo, _) in widths.items()}
                mask = self._lower_mask(value.shape.only(result.dependent_dims), widths, bound_dim, bound_lo, bound_hi, i)
                boundary = value.shift(lower, new_shape=result.shape, val_fun=lambda v: self.pad(v, widths) * mask, bias_fun=lambda b: ZERO.pad(b, widths))
                result += boundary
            for i in range(bound_hi):
                lower = {dim: i - lo - hi if dim == bound_dim else -lo for dim, (lo, hi) in widths.items()}
                mask = self._upper_mask(value.shape.only(result.dependent_dims), widths, bound_dim, bound_lo, bound_hi, i)
                boundary = value.shift(lower, new_shape=result.shape, val_fun=lambda v: self.pad(v, widths) * mask, bias_fun=lambda b: ZERO.pad(b, widths))  # ~ half the computation time
                result += boundary  # this does basically nothing if value is the identity
        return result

    def _lower_mask(self, shape, widths, bound_dim, bound_lo, bound_hi, i):
        # key = (shape, tuple(widths.keys()), tuple(widths.values()), bound_dim, bound_lo, bound_hi, i)
        # if key in _BoundaryExtrapolation._CACHED_LOWER_MASKS:
        #     result = math.tensor(_BoundaryExtrapolation._CACHED_LOWER_MASKS[key])
        #     _BoundaryExtrapolation._CACHED_LOWER_MASKS[key] = result
        #     return result
        # else:
            mask = ZERO.pad(math.zeros(shape), {bound_dim: (bound_lo - i - 1, 0)})
            mask = ONE.pad(mask, {bound_dim: (1, 0)})
            mask = ZERO.pad(mask, {dim: (i, bound_hi) if dim == bound_dim else (lo, hi) for dim, (lo, hi) in widths.items()})
            # _BoundaryExtrapolation._CACHED_LOWER_MASKS[key] = mask
            return mask

    def _upper_mask(self, shape, widths, bound_dim, bound_lo, bound_hi, i):
        # key = (shape, tuple(widths.keys()), tuple(widths.values()), bound_dim, bound_lo, bound_hi, i)
        # if key in _BoundaryExtrapolation._CACHED_UPPER_MASKS:
        #     result = math.tensor(_BoundaryExtrapolation._CACHED_UPPER_MASKS[key])
        #     _BoundaryExtrapolation._CACHED_UPPER_MASKS[key] = result
        #     return result
        # else:
            mask = ZERO.pad(math.zeros(shape), {bound_dim: (0, bound_hi - i - 1)})
            mask = ONE.pad(mask, {bound_dim: (0, 1)})
            mask = ZERO.pad(mask, {dim: (bound_lo, i) if dim == bound_dim else (lo, hi) for dim, (lo, hi) in widths.items()})
            # _BoundaryExtrapolation._CACHED_UPPER_MASKS[key] = mask
            return mask

    def sparse_pad_values(self, value: Tensor, connectivity: Tensor, dim: str, upper_edge: bool, **kwargs) -&gt; Tensor:
        from ._sparse import stored_indices
        from ._ops import arange
        dual_dim = dual(value).name
        primal_dim = dual(value).name[1:]
        # --- Gather the edge values ---
        indices = stored_indices(connectivity, invalid=&#39;discard&#39;)
        gathered = value[{dual_dim: indices[primal_dim]}]
        # --- Scatter, but knowing there is only one entry per row &amp; col, we can simply permute ---
        inv_perm = arange(dual(connectivity))[{dual_dim: indices[dual_dim]}]
        inv_perm = rename_dims(inv_perm, instance, dual(connectivity))
        return gathered[{instance(gathered).name: inv_perm}]


class _PeriodicExtrapolation(_CopyExtrapolation):
    &#34;&#34;&#34; Periodic extrapolation in n dimensions. &#34;&#34;&#34;
    def __repr__(self):
        return &#39;periodic&#39;

    def spatial_gradient(self):
        return self

    def determines_boundary_values(self, boundary_key: Union[Tuple[str, bool], str]) -&gt; bool:
        if isinstance(boundary_key, tuple):
            is_upper = boundary_key[1]
            return is_upper
        else:
            raise AssertionError(f&#34;Periodic extrapolation only supported for grids but got boundary key &#39;{boundary_key}&#39;&#34;)

    @property
    def is_flexible(self) -&gt; bool:
        return False

    def transform_coordinates(self, coordinates: Tensor, shape: Shape, **kwargs) -&gt; Tensor:
        return coordinates % shape.spatial

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        if upper_edge:
            return value[{dim: slice(width)}]
        else:
            return value[{dim: slice(-width, None)}]

    def _pad_linear_tracer(self, value: &#39;ShiftLinTracer&#39;, widths: dict) -&gt; &#39;ShiftLinTracer&#39;:
        if value.shape.get_sizes(tuple(widths.keys())) != value.source.shape.get_sizes(tuple(widths.keys())):
            raise NotImplementedError(&#34;Periodicity does not match input: %s but input has %s. This can happen when padding an already padded or sliced tensor.&#34; % (value.shape.only(tuple(widths.keys())), value.source.shape.only(tuple(widths.keys()))))
        lower = {dim: -lo for dim, (lo, _) in widths.items()}
        return value.shift(lower, new_shape=value.shape.after_pad(widths), val_fun=lambda v: self.pad(v, widths), bias_fun=lambda b: ZERO.pad(b, widths))

    def shortest_distance(self, start: Tensor, end: Tensor, domain_size: Tensor):
        dx = end - start
        return (dx + domain_size / 2) % domain_size - domain_size / 2


class _SymmetricExtrapolation(_CopyExtrapolation):
    &#34;&#34;&#34;Mirror with the boundary value occurring twice.&#34;&#34;&#34;

    def __repr__(self):
        return &#39;symmetric&#39;

    def spatial_gradient(self):
        return -self

    @property
    def is_flexible(self) -&gt; bool:
        return True

    def transform_coordinates(self, coordinates: Tensor, shape: Shape, **kwargs) -&gt; Tensor:
        coordinates = coordinates % (2 * shape)
        return ((2 * shape - 1) - abs((2 * shape - 1) - 2 * coordinates)) // 2

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        if upper_edge:
            return value[{dim: slice(-1, -width-1, -1)}]
        else:
            return value[{dim: slice(width-1, None, -1)}]

    def _pad_linear_tracer(self, value: &#39;ShiftLinTracer&#39;, widths: dict) -&gt; &#39;ShiftLinTracer&#39;:
        &#34;&#34;&#34;
        *Warning*:
        This implementation discards corners, i.e. values that lie outside the original tensor in more than one dimension.
        These are typically sliced off in differential operators. Corners are instead assigned the value 0.
        To take corners into account, call pad() for each axis individually. This is inefficient with ShiftLinTracer.

        Args:
          value: ShiftLinTracer:
          widths: dict:

        Returns:

        &#34;&#34;&#34;
        lower = {dim: -lo for dim, (lo, _) in widths.items()}
        result = value.shift(lower, new_shape=value.shape.after_pad(widths), val_fun=lambda v: ZERO.pad(v, widths), bias_fun=lambda b: ZERO.pad(b, widths))  # inner values  ~half the computation time
        for bound_dim, (bound_lo, bound_hi) in widths.items():
            for i in range(bound_lo):  # i=0 means outer
                # this sets corners to 0
                lower = {dim: bound_lo-1-2*i if dim == bound_dim else -lo for dim, (lo, _) in widths.items()}
                mask = self._lower_mask(value.shape.only(result.dependent_dims), widths, bound_dim, bound_lo, bound_hi, i)
                boundary = value.shift(lower, new_shape=result.shape, val_fun=lambda v: self.pad(v, widths) * mask, bias_fun=lambda b: ZERO.pad(b, widths))
                result += boundary
            for i in range(bound_hi):
                lower = {dim: -(bound_hi-1-2*i) - bound_lo - bound_hi if dim == bound_dim else -lo for dim, (lo, hi) in widths.items()}
                mask = self._upper_mask(value.shape.only(result.dependent_dims), widths, bound_dim, bound_lo, bound_hi, i)
                boundary = value.shift(lower, new_shape=result.shape, val_fun=lambda v: self.pad(v, widths) * mask, bias_fun=lambda b: ZERO.pad(b, widths))  # ~ half the computation time
                result += boundary  # this does basically nothing if value is the identity
        return result

    def _lower_mask(self, shape, widths, bound_dim, bound_lo, bound_hi, i):
        # key = (shape, tuple(widths.keys()), tuple(widths.values()), bound_dim, bound_lo, bound_hi, i)
        # if key in _BoundaryExtrapolation._CACHED_LOWER_MASKS:
        #     result = math.tensor(_BoundaryExtrapolation._CACHED_LOWER_MASKS[key])
        #     _BoundaryExtrapolation._CACHED_LOWER_MASKS[key] = result
        #     return result
        # else:
            mask = ZERO.pad(math.zeros(shape), {bound_dim: (bound_lo - i - 1, 0)})
            mask = ONE.pad(mask, {bound_dim: (1, 0)})
            mask = ZERO.pad(mask, {dim: (i, bound_hi) if dim == bound_dim else (lo, hi) for dim, (lo, hi) in widths.items()})
            # _BoundaryExtrapolation._CACHED_LOWER_MASKS[key] = mask
            return mask

    def _upper_mask(self, shape, widths, bound_dim, bound_lo, bound_hi, i):
        # key = (shape, tuple(widths.keys()), tuple(widths.values()), bound_dim, bound_lo, bound_hi, i)
        # if key in _BoundaryExtrapolation._CACHED_UPPER_MASKS:
        #     result = math.tensor(_BoundaryExtrapolation._CACHED_UPPER_MASKS[key])
        #     _BoundaryExtrapolation._CACHED_UPPER_MASKS[key] = result
        #     return result
        # else:
            mask = ZERO.pad(math.zeros(shape), {bound_dim: (0, bound_hi - i - 1)})
            mask = ONE.pad(mask, {bound_dim: (0, 1)})
            mask = ZERO.pad(mask, {dim: (bound_lo, i) if dim == bound_dim else (lo, hi) for dim, (lo, hi) in widths.items()})
            # _BoundaryExtrapolation._CACHED_UPPER_MASKS[key] = mask
            return mask


class _AntiSymmetricExtrapolation(_SymmetricExtrapolation):
    &#34;&#34;&#34;Like _SymmetricExtrapolation but symmetric counterparts are negated for padding&#34;&#34;&#34;

    def __repr__(self):
        return &#39;antisymmetric&#39;

    def pad_values(self, *args, **kwargs) -&gt; Tensor:
        return -super().pad_values(*args, **kwargs)

    def _pad_linear_tracer(self, value: &#39;ShiftLinTracer&#39;, widths: dict) -&gt; &#39;ShiftLinTracer&#39;:
        &#34;&#34;&#34;
        *Warning*:
        This implementation discards corners, i.e. values that lie outside the original tensor in more than one dimension.
        These are typically sliced off in differential operators. Corners are instead assigned the value 0.
        To take corners into account, call pad() for each axis individually. This is inefficient with ShiftLinTracer.

        Args:
          value: ShiftLinTracer:
          widths: dict:

        Returns:

        &#34;&#34;&#34;
        lower = {dim: -lo for dim, (lo, _) in widths.items()}
        result = value.shift(lower, new_shape=value.shape.after_pad(widths), val_fun=lambda v: ZERO.pad(v, widths), bias_fun=lambda b: ZERO.pad(b, widths))  # inner values  ~half the computation time
        for bound_dim, (bound_lo, bound_hi) in widths.items():
            for i in range(bound_lo):  # i=0 means outer
                # this sets corners to 0
                lower = {dim: bound_lo-1-2*i if dim == bound_dim else -lo for dim, (lo, _) in widths.items()}
                mask = self._lower_mask(value.shape.only(result.dependent_dims), widths, bound_dim, bound_lo, bound_hi, i)
                boundary = value.shift(lower, new_shape=result.shape, val_fun=lambda v: self.pad(v, widths) * mask, bias_fun=lambda b: ZERO.pad(b, widths))
                result -= boundary
            for i in range(bound_hi):
                lower = {dim: -(bound_hi-1-2*i) - bound_lo - bound_hi if dim == bound_dim else -lo for dim, (lo, hi) in widths.items()}
                mask = self._upper_mask(value.shape.only(result.dependent_dims), widths, bound_dim, bound_lo, bound_hi, i)
                boundary = value.shift(lower, new_shape=result.shape, val_fun=lambda v: self.pad(v, widths) * mask, bias_fun=lambda b: ZERO.pad(b, widths))  # ~ half the computation time
                result -= boundary  # this does basically nothing if value is the identity
        return result


class _ReflectExtrapolation(_CopyExtrapolation):
    &#34;&#34;&#34;Mirror of inner elements. The boundary value is not duplicated.&#34;&#34;&#34;

    def __repr__(self):
        return &#39;reflect&#39;

    def spatial_gradient(self):
        return -self

    @property
    def is_flexible(self) -&gt; bool:
        return True

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        if upper_edge:
            return value[{dim: slice(-2, -2-width, -1)}]
        else:
            return value[{dim: slice(width, 0, -1)}]

    def transform_coordinates(self, coordinates: Tensor, shape: Shape, **kwargs) -&gt; Tensor:
        coordinates = coordinates % (2 * shape - 2)
        return (shape - 1) - math.abs_((shape - 1) - coordinates)

    def _pad_linear_tracer(self, value: &#39;ShiftLinTracer&#39;, widths: dict) -&gt; &#39;ShiftLinTracer&#39;:
        &#34;&#34;&#34;
        *Warning*:
        This implementation discards corners, i.e. values that lie outside the original tensor in more than one dimension.
        These are typically sliced off in differential operators. Corners are instead assigned the value 0.
        To take corners into account, call pad() for each axis individually. This is inefficient with ShiftLinTracer.

        Args:
          value: ShiftLinTracer:
          widths: dict:

        Returns:

        &#34;&#34;&#34;
        lower = {dim: -lo for dim, (lo, _) in widths.items()}
        result = value.shift(lower, new_shape=value.shape.after_pad(widths), val_fun=lambda v: ZERO.pad(v, widths), bias_fun=lambda b: ZERO.pad(b, widths))  # inner values  ~half the computation time
        for bound_dim, (bound_lo, bound_hi) in widths.items():
            for i in range(bound_lo):  # i=0 means outer
                # this sets corners to 0
                lower = {dim: bound_lo-2*i if dim == bound_dim else -lo for dim, (lo, _) in widths.items()}
                mask = self._lower_mask(value.shape.only(result.dependent_dims), widths, bound_dim, bound_lo, bound_hi, i)
                boundary = value.shift(lower, new_shape=result.shape, val_fun=lambda v: self.pad(v, widths) * mask, bias_fun=lambda b: ZERO.pad(b, widths))
                result += boundary
            for i in range(bound_hi):
                lower = {dim: -(bound_hi-2*i) - bound_lo - bound_hi if dim == bound_dim else -lo for dim, (lo, hi) in widths.items()}
                mask = self._upper_mask(value.shape.only(result.dependent_dims), widths, bound_dim, bound_lo, bound_hi, i)
                boundary = value.shift(lower, new_shape=result.shape, val_fun=lambda v: self.pad(v, widths) * mask, bias_fun=lambda b: ZERO.pad(b, widths))  # ~ half the computation time
                result += boundary  # this does basically nothing if value is the identity
        return result

    def _lower_mask(self, shape, widths, bound_dim, bound_lo, bound_hi, i):
        # key = (shape, tuple(widths.keys()), tuple(widths.values()), bound_dim, bound_lo, bound_hi, i)
        # if key in _BoundaryExtrapolation._CACHED_LOWER_MASKS:
        #     result = math.tensor(_BoundaryExtrapolation._CACHED_LOWER_MASKS[key])
        #     _BoundaryExtrapolation._CACHED_LOWER_MASKS[key] = result
        #     return result
        # else:
            mask = ZERO.pad(math.zeros(shape), {bound_dim: (bound_lo - i - 1, 0)})
            mask = ONE.pad(mask, {bound_dim: (1, 0)})
            mask = ZERO.pad(mask, {dim: (i, bound_hi) if dim == bound_dim else (lo, hi) for dim, (lo, hi) in widths.items()})
            # _BoundaryExtrapolation._CACHED_LOWER_MASKS[key] = mask
            return mask

    def _upper_mask(self, shape, widths, bound_dim, bound_lo, bound_hi, i):
        # key = (shape, tuple(widths.keys()), tuple(widths.values()), bound_dim, bound_lo, bound_hi, i)
        # if key in _BoundaryExtrapolation._CACHED_UPPER_MASKS:
        #     result = math.tensor(_BoundaryExtrapolation._CACHED_UPPER_MASKS[key])
        #     _BoundaryExtrapolation._CACHED_UPPER_MASKS[key] = result
        #     return result
        # else:
            mask = ZERO.pad(math.zeros(shape), {bound_dim: (0, bound_hi - i - 1)})
            mask = ONE.pad(mask, {bound_dim: (0, 1)})
            mask = ZERO.pad(mask, {dim: (bound_lo, i) if dim == bound_dim else (lo, hi) for dim, (lo, hi) in widths.items()})
            # _BoundaryExtrapolation._CACHED_UPPER_MASKS[key] = mask
            return mask


class _AntiReflectExtrapolation(_ReflectExtrapolation):
    &#34;&#34;&#34;Like _ReflectExtrapolation but symmetric counterparts are negated for padding&#34;&#34;&#34;

    def __repr__(self):
        return &#39;antireflect&#39;

    def pad_values(self, *args, **kwargs) -&gt; Tensor:
        return -super().pad_values(*args, **kwargs)

    def _pad_linear_tracer(self, value: &#39;ShiftLinTracer&#39;, widths: dict) -&gt; &#39;ShiftLinTracer&#39;:
        &#34;&#34;&#34;
        *Warning*:
        This implementation discards corners, i.e. values that lie outside the original tensor in more than one dimension.
        These are typically sliced off in differential operators. Corners are instead assigned the value 0.
        To take corners into account, call pad() for each axis individually. This is inefficient with ShiftLinTracer.

        Args:
          value: ShiftLinTracer:
          widths: dict:

        Returns:

        &#34;&#34;&#34;
        lower = {dim: -lo for dim, (lo, _) in widths.items()}
        result = value.shift(lower, new_shape=value.shape.after_pad(widths), val_fun=lambda v: ZERO.pad(v, widths), bias_fun=lambda b: ZERO.pad(b, widths))  # inner values  ~half the computation time
        for bound_dim, (bound_lo, bound_hi) in widths.items():
            for i in range(bound_lo):  # i=0 means outer
                # this sets corners to 0
                lower = {dim: bound_lo-2*i if dim == bound_dim else -lo for dim, (lo, _) in widths.items()}
                mask = self._lower_mask(value.shape.only(result.dependent_dims), widths, bound_dim, bound_lo, bound_hi, i)
                boundary = value.shift(lower, new_shape=result.shape, val_fun=lambda v: self.pad(v, widths) * mask, bias_fun=lambda b: ZERO.pad(b, widths))
                result -= boundary
            for i in range(bound_hi):
                lower = {dim: -(bound_hi-2*i) - bound_lo - bound_hi if dim == bound_dim else -lo for dim, (lo, hi) in widths.items()}
                mask = self._upper_mask(value.shape.only(result.dependent_dims), widths, bound_dim, bound_lo, bound_hi, i)
                boundary = value.shift(lower, new_shape=result.shape, val_fun=lambda v: self.pad(v, widths) * mask, bias_fun=lambda b: ZERO.pad(b, widths))  # ~ half the computation time
                result -= boundary  # this does basically nothing if value is the identity
        return result


class _SymmetricGradientExtrapolation(Extrapolation):

    def to_dict(self) -&gt; dict:
        return {&#39;type&#39;: &#39;symmetric-gradient&#39;}

    def spatial_gradient(self) -&gt; &#39;Extrapolation&#39;:
        raise NotImplementedError

    def valid_outer_faces(self, dim) -&gt; Tuple[bool, bool]:
        raise NotImplementedError  # probably return True, True but this hasn&#39;t been used on grids yet

    @property
    def is_flexible(self) -&gt; bool:
        return True

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        anti_s = ANTIREFLECT.pad_values(value, width, dim, upper_edge, already_padded=already_padded, **kwargs)
        edge = value[{dim: -1}] if upper_edge else value[{dim: 0}]
        return anti_s + 2 * edge


class _NoExtrapolation(Extrapolation):  # singleton

    @property
    def shape(self):
        return EMPTY_SHAPE

    def to_dict(self) -&gt; dict:
        return {&#39;type&#39;: &#39;none&#39;}

    def pad(self, value: Tensor, widths: dict, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        return value

    def spatial_gradient(self) -&gt; &#39;Extrapolation&#39;:
        return self

    def determines_boundary_values(self, boundary_key: Union[Tuple[str, bool], str]) -&gt; bool:
        return False

    def __value_attrs__(self):
        return ()

    @property
    def is_flexible(self) -&gt; bool:
        raise AssertionError(f&#34;is_flexible not defined by {self.__class__}&#34;)

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        return math.zeros(value.shape._replace_single_size(dim, 0))

    def __repr__(self):
        return &#34;none&#34;

    def __abs__(self):
        return self

    def __neg__(self):
        return self

    def __add__(self, other):
        return self

    def __radd__(self, other):
        return self

    def __sub__(self, other):
        return self

    def __rsub__(self, other):
        return self

    def __mul__(self, other):
        return self

    def __rmul__(self, other):
        return self

    def __truediv__(self, other):
        return self

    def __rtruediv__(self, other):
        return self


class Undefined(Extrapolation):
    &#34;&#34;&#34;
    The extrapolation is unknown and must be replaced before usage.
    Any access to outside values will raise an AssertionError.
    &#34;&#34;&#34;

    def __init__(self, derived_from: Extrapolation):
        super().__init__(-1)
        self.derived_from = derived_from

    @property
    def shape(self):
        return EMPTY_SHAPE

    def to_dict(self) -&gt; dict:
        return {&#39;type&#39;: &#39;undefined&#39;, &#39;derived_from&#39;: self.derived_from.to_dict()}

    def pad(self, value: Tensor, widths: dict, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        for (lo, up) in widths.items():
            assert lo == 0 and up == 0, &#34;Undefined extrapolation&#34;
        return value

    def spatial_gradient(self) -&gt; &#39;Extrapolation&#39;:
        return self

    def determines_boundary_values(self, boundary_key: Union[Tuple[str, bool], str]) -&gt; bool:
        return self.derived_from.determines_boundary_values(boundary_key)

    @property
    def is_flexible(self) -&gt; bool:
        raise AssertionError(&#34;Undefined extrapolation&#34;)

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        raise AssertionError(&#34;Undefined extrapolation&#34;)

    def __repr__(self):
        return &#34;undefined&#34;

    def __abs__(self):
        return self

    def __neg__(self):
        return self

    def __add__(self, other):
        return self

    def __radd__(self, other):
        return self

    def __sub__(self, other):
        return self

    def __rsub__(self, other):
        return self

    def __mul__(self, other):
        return self

    def __rmul__(self, other):
        return self

    def __truediv__(self, other):
        return self

    def __rtruediv__(self, other):
        return self


ZERO = ConstantExtrapolation(0)
&#34;&#34;&#34; Extrapolates with the constant value 0 (Dirichlet boundary condition). &#34;&#34;&#34;
ONE = ConstantExtrapolation(1)
&#34;&#34;&#34; Extrapolates with the constant value 1 (Dirichlet boundary condition). &#34;&#34;&#34;
PERIODIC = _PeriodicExtrapolation(1)
&#34;&#34;&#34; Extends a grid by tiling it (Periodic boundary condition). &#34;&#34;&#34;
ZERO_GRADIENT = _ZeroGradient(2)
&#34;&#34;&#34; Extends a grid with its edge values (Neumann boundary condition). The value of a point lying outside the grid is determined by the closest grid value(s). &#34;&#34;&#34;
BOUNDARY = ZERO_GRADIENT
# undocumented, use ZERO_GRADIENT instead
SYMMETRIC = _SymmetricExtrapolation(3)
&#34;&#34;&#34; Extends a grid by tiling it. Every other copy of the grid is flipped. Edge values occur twice per seam. &#34;&#34;&#34;
ANTISYMMETRIC = _AntiSymmetricExtrapolation(3)
&#34;&#34;&#34; Like SYMMETRIC but extends a grid with the negative value of the corresponding counterpart instead. &#34;&#34;&#34;
REFLECT = _ReflectExtrapolation(4)
&#34;&#34;&#34; Like SYMMETRIC but the edge values are not copied and only occur once per seam. &#34;&#34;&#34;
ANTIREFLECT = _AntiReflectExtrapolation(4)
&#34;&#34;&#34; Like REFLECT but extends a grid with the negative value of the corresponding counterpart instead. &#34;&#34;&#34;
SYMMETRIC_GRADIENT = _SymmetricGradientExtrapolation(3)
&#34;&#34;&#34; Extrapolates in a continuous manner. The normal component of the spatial gradient is symmetric at the boundaries. The outer-most valid difference is duplicated. &#34;&#34;&#34;

NONE = _NoExtrapolation(-1)
&#34;&#34;&#34; Raises AssertionError when used to determine outside values. Padding operations will have no effect with this extrapolation. &#34;&#34;&#34;


_PRIMITIVES = {  # used by as_boundary() and from_dict()
    &#39;periodic&#39;: PERIODIC,
    &#39;zero&#39;: ZERO,
    &#39;one&#39;: ONE,
    &#39;zero-gradient&#39;: ZERO_GRADIENT,
    &#39;âˆ‡=0&#39;: ZERO_GRADIENT,
    &#39;boundary&#39;: ZERO_GRADIENT,  # deprecated
    &#39;symmetric&#39;: SYMMETRIC,
    &#39;symmetric-gradient&#39;: SYMMETRIC_GRADIENT,
    &#39;antisymmetric&#39;: ANTISYMMETRIC,
    &#39;reflect&#39;: REFLECT,
    &#39;antireflect&#39;: ANTISYMMETRIC,
}


def as_extrapolation(obj) -&gt; Extrapolation:
    &#34;&#34;&#34;
    Creates an `Extrapolation` from a descriptor object.

    Args:
        obj: Extrapolation specification, one of the following:

            * `Extrapolation`
            * Primitive name as `str`: periodic, zero, one, zero-gradient, symmetric, symmetric-gradient, antisymmetric, reflect, antireflect
            * `dict` containing exactly the keys `&#39;normal&#39;` and `&#39;tangential&#39;`
            * `dict` mapping spatial dimension names to extrapolations

    Returns:
        `Extrapolation`
    &#34;&#34;&#34;
    if isinstance(obj, Extrapolation):
        return obj
    if obj is None:
        return NONE
    if isinstance(obj, str):
        assert obj in _PRIMITIVES, f&#34;Unrecognized extrapolation type: &#39;{obj}&#39;&#34;
        return _PRIMITIVES[obj]
    if isinstance(obj, dict):
        if &#39;normal&#39; in obj or &#39;tangential&#39; in obj:
            assert &#39;normal&#39; in obj and &#39;tangential&#39; in obj, f&#34;Normal/tangential dict requires both entries &#39;normal&#39; and &#39;tangential&#39; but got {obj}&#34;
            assert len(obj) == 2, f&#34;Normal/tangential dict must only contain entries &#39;normal&#39; and &#39;tangential&#39; but got {obj}&#34;
            normal = as_extrapolation(obj[&#39;normal&#39;])
            tangential = as_extrapolation(obj[&#39;tangential&#39;])
            return combine_by_direction(normal=normal, tangential=tangential)
        else:
            ext = {dim: (as_extrapolation(spec[0]), as_extrapolation(spec[1])) if isinstance(spec, tuple) else as_extrapolation(spec) for dim, spec in obj.items()}
            return combine_sides(**ext)
    return ConstantExtrapolation(obj)


def combine_sides(boundary_dict: Dict[Hashable, Extrapolation] = None, **extrapolations: Union[Extrapolation, tuple, Number]) -&gt; Extrapolation:
    &#34;&#34;&#34;
    Specify extrapolations for each side / face of a box.

    Args:
        boundary_dict: Extrapolations by hashable boundary key.
        **extrapolations: map from dim: str -&gt; `Extrapolation` or `tuple` (lower, upper)

    Returns:
        `Extrapolation`
    &#34;&#34;&#34;
    boundary_dict = dict(boundary_dict) if boundary_dict is not None else {}
    for dim, ext in extrapolations.items():
        if isinstance(ext, tuple):
            assert len(ext) == 2, &#34;Tuple must contain exactly two elements, (lower, upper)&#34;
            lower = as_extrapolation(ext[0])
            upper = as_extrapolation(ext[1])
            boundary_dict[(dim, False)] = lower
            boundary_dict[(dim, True)] = upper
        else:
            boundary_dict[(dim, False)] = boundary_dict[(dim, True)] = as_extrapolation(ext)
    if len(set(boundary_dict.values())) == 1:  # All equal -&gt; return any
        return next(iter(boundary_dict.values()))
    else:
        return _MixedExtrapolation(boundary_dict)


class _MixedExtrapolation(Extrapolation):
    &#34;&#34;&#34;
    A mixed extrapolation uses different extrapolations for different sides.
    Each side is identified by a hashable object, such as a `str` or `tupleÂ´.
    &#34;&#34;&#34;

    def __init__(self, ext_by_boundary: Dict[Hashable, Extrapolation]):
        &#34;&#34;&#34;
        Args:
            ext_by_boundary: key: str -&gt; Extrapolation
        &#34;&#34;&#34;
        super().__init__(pad_rank=None)
        assert all(isinstance(e, Extrapolation) for e in ext_by_boundary.values())
        assert len(set(ext_by_boundary.values())) &gt;= 2, f&#34;Extrapolation can be simplified: {ext_by_boundary}&#34;
        self.ext = ext_by_boundary

    @property
    def shape(self):
        return merge_shapes(*self.ext.values())

    def to_dict(self) -&gt; dict:
        return {
            &#39;type&#39;: &#39;mixed&#39;,
            &#39;dims&#39;: {k: ext.to_dict() for k, ext in self.ext.items()}
        }

    def __value_attrs__(self):
        return &#39;ext&#39;,

    def __eq__(self, other):
        if not isinstance(other, _MixedExtrapolation):
            return False
        return self.ext == other.ext

    def __hash__(self):
        return hash(frozenset(self.ext.items()))

    def __repr__(self):
        return repr(self.ext)

    def spatial_gradient(self) -&gt; Extrapolation:
        return combine_sides({k: ext.spatial_gradient() for k, ext in self.ext.items()})

    def determines_boundary_values(self, boundary_key: Union[Tuple[str, bool], str]) -&gt; bool:
        return self.ext[boundary_key].determines_boundary_values(boundary_key)

    def is_copy_pad(self, dim: str, upper_edge: bool):
        return self.ext[(dim, upper_edge)].is_copy_pad(dim, upper_edge)

    @property
    def is_flexible(self) -&gt; bool:
        return any([ext.is_flexible for ext in self.ext.values()])

    def pad(self, value: Tensor, widths: dict, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        &#34;&#34;&#34;Pads a tensor using multiple extrapolations.&#34;&#34;&#34;
        extrapolations = set(self.ext.values())
        extrapolations = tuple(sorted(extrapolations, key=lambda e: e.pad_rank))
        already_padded = {} if already_padded is None else dict(already_padded)
        for ext in extrapolations:
            ext_widths = {dim: (l if self.ext[(dim, False)] == ext else 0, u if self.ext[(dim, True)] == ext else 0) for dim, (l, u) in widths.items()}
            value = ext.pad(value, ext_widths, already_padded=already_padded, **kwargs)
            already_padded.update(ext_widths)
        return value

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        extrap: Extrapolation = self.ext[(dim, upper_edge)]
        return extrap.pad_values(value, width, dim, upper_edge, already_padded=already_padded, **kwargs)

    def sparse_pad_values(self, value: Tensor, connectivity: Tensor, boundary, **kwargs) -&gt; Tensor:
        return self.ext[boundary].sparse_pad_values(value, connectivity, boundary, **kwargs)

    def transform_coordinates(self, coordinates: Tensor, shape: Shape, **kwargs) -&gt; Tensor:
        assert len(self.ext) / 2 == len(shape.spatial) == coordinates.vector.size
        result = []
        for dim in shape.spatial.unstack():
            dim_coords = coordinates[[dim.name]]
            le = self.ext[(dim.name, False)]
            ue = self.ext[(dim.name, True)]
            if le == ue:
                result.append(le.transform_coordinates(dim_coords, dim, **kwargs))
            else:  # separate boundary for lower and upper face
                lower = le.transform_coordinates(dim_coords, dim, **kwargs)
                upper = ue.transform_coordinates(dim_coords, dim, **kwargs)
                result.append(math.where(dim_coords &lt;= 0, lower, upper))
        if &#39;vector&#39; in result[0].shape:
            return concat(result, channel(&#39;vector&#39;))
        else:
            return stack(result, channel(&#39;vector&#39;))

    def __getitem__(self, item):
        if isinstance(item, dict):
            if all(isinstance(k, tuple) for k in self.ext):
                all_dims = [dim for dim, _ in self.ext.keys()]
                return combine_sides({k: ext._getitem_with_domain(item, k[0], k[1], all_dims) for k, ext in self.ext.items()})
            return combine_sides({k: ext[item] for k, ext in self.ext.items()})
        else:
            return self.ext[item]

    def __add__(self, other):
        return self._op2(other, lambda e1, e2: e1 + e2)

    def __radd__(self, other):
        return self._op2(other, lambda e1, e2: e2 + e1)

    def __sub__(self, other):
        return self._op2(other, lambda e1, e2: e1 - e2)

    def __rsub__(self, other):
        return self._op2(other, lambda e1, e2: e2 - e1)

    def __mul__(self, other):
        return self._op2(other, lambda e1, e2: e1 * e2)

    def __rmul__(self, other):
        return self._op2(other, lambda e1, e2: e2 * e1)

    def __truediv__(self, other):
        return self._op2(other, lambda e1, e2: e1 / e2)

    def __rtruediv__(self, other):
        return self._op2(other, lambda e1, e2: e2 / e1)

    def _op2(self, other, operator):
        if isinstance(other, _MixedExtrapolation):
            assert self.ext.keys() == other.ext.keys()
            return combine_sides({k: operator(ext, other.ext[k]) for k, ext in self.ext.items()})
        else:
            return combine_sides({k: operator(ext, other) for k, ext in self.ext.items()})

    def __abs__(self):
        return combine_sides({k: abs(ext) for k, ext in self.ext.items()})

    def __neg__(self):
        return combine_sides({k: -ext for k, ext in self.ext.items()})


class _NormalTangentialExtrapolation(Extrapolation):

    def __init__(self, normal: Extrapolation, tangential: Extrapolation):
        super().__init__(pad_rank=min(normal.pad_rank, tangential.pad_rank))
        self.normal = normal
        self.tangential = tangential

    @property
    def shape(self):
        return merge_shapes(self.normal, self.tangential)

    def to_dict(self) -&gt; dict:
        return {
            &#39;type&#39;: &#39;normal-tangential&#39;,
            &#39;normal&#39;: self.normal.to_dict(),
            &#39;tangential&#39;: self.tangential.to_dict(),
        }

    def __value_attrs__(self):
        return &#39;normal&#39;, &#39;tangential&#39;

    def __repr__(self):
        return f&#34;normal={self.normal}, tangential={self.tangential}&#34;

    def spatial_gradient(self) -&gt; &#39;Extrapolation&#39;:
        return combine_by_direction(self.normal.spatial_gradient(), self.tangential.spatial_gradient())

    def valid_outer_faces(self, dim) -&gt; Tuple[bool, bool]:
        return self.normal.valid_outer_faces(dim)

    def is_copy_pad(self, dim: str, upper_edge: bool):
        return False  # normal and tangential might copy from different places, so no.

    @property
    def is_flexible(self) -&gt; bool:
        return self.normal.is_flexible

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        if &#39;vector&#39; not in value.shape:
            warnings.warn(f&#39;{self} adding a vector dimension to tensor {value.shape}&#39;)
            from . import expand
            value = expand(value, channel(vector=spatial(value).names))
        assert value.vector.item_names is not None, &#34;item_names must be present when padding with normal-tangential&#34;
        result = []
        for component_name, component in zip(value.vector.item_names, value.vector):
            ext = self.normal if component_name == dim else self.tangential
            result.append(ext.pad_values(component, width, dim, upper_edge, already_padded=already_padded, **kwargs))
        from ._magic_ops import stack
        result = stack(result, value.shape.only(&#39;vector&#39;))
        return result

    def _getitem_with_domain(self, item: dict, dim: str, upper_edge: bool, all_dims: Sequence[str]):
        if &#39;vector&#39; not in item:
            return self
        component = item[&#39;vector&#39;]
        assert isinstance(component, str), f&#34;Selecting a component of normal/tangential must be done by dimension name but got {component}&#34;
        if component == dim:
            return self.normal
        else:
            return self.tangential

    def __eq__(self, other):
        return isinstance(other, _NormalTangentialExtrapolation) and self.normal == other.normal and self.tangential == other.tangential

    def __hash__(self):
        return hash(self.normal) + hash(self.tangential)

    def __add__(self, other):
        return self._op2(other, lambda e1, e2: e1 + e2)

    def __radd__(self, other):
        return self._op2(other, lambda e1, e2: e2 + e1)

    def __sub__(self, other):
        return self._op2(other, lambda e1, e2: e1 - e2)

    def __rsub__(self, other):
        return self._op2(other, lambda e1, e2: e2 - e1)

    def __mul__(self, other):
        return self._op2(other, lambda e1, e2: e1 * e2)

    def __rmul__(self, other):
        return self._op2(other, lambda e1, e2: e2 * e1)

    def __truediv__(self, other):
        return self._op2(other, lambda e1, e2: e1 / e2)

    def __rtruediv__(self, other):
        return self._op2(other, lambda e1, e2: e2 / e1)

    def _op2(self, other, operator):
        if isinstance(other, _NormalTangentialExtrapolation):
            return combine_by_direction(normal=operator(self.normal, other.normal), tangential=operator(self.tangential, other.tangential))
        else:
            return combine_by_direction(normal=operator(self.normal, other), tangential=operator(self.tangential, other))

    def __abs__(self):
        return combine_by_direction(normal=abs(self.normal), tangential=abs(self.tangential))

    def __neg__(self):
        return combine_by_direction(normal=-self.normal, tangential=-self.tangential)


def combine_by_direction(normal: Union[Extrapolation, float, Tensor], tangential: Union[Extrapolation, float, Tensor]) -&gt; Extrapolation:
    &#34;&#34;&#34;
    Use a different extrapolation for the normal component of vector-valued tensors.

    Args:
        normal: Extrapolation for the component that is orthogonal to the boundary.
        tangential: Extrapolation for the component that is tangential to the boundary.

    Returns:
        `Extrapolation`
    &#34;&#34;&#34;
    normal = as_extrapolation(normal)
    tangential = as_extrapolation(tangential)
    return normal if normal == tangential else _NormalTangentialExtrapolation(normal, tangential)


def from_dict(dictionary: dict) -&gt; Extrapolation:
    &#34;&#34;&#34;
    Loads an `Extrapolation` object from a dictionary that was created using `Extrapolation.to_dict()`.

    Args:
        dictionary: serializable dictionary holding all extrapolation properties

    Returns:
        Loaded extrapolation
    &#34;&#34;&#34;
    etype = dictionary[&#39;type&#39;]
    if etype in _PRIMITIVES:
        return _PRIMITIVES[etype]
    elif etype == &#39;constant&#39;:
        return ConstantExtrapolation(dictionary[&#39;value&#39;])
    elif etype == &#39;mixed&#39;:
        dims: Dict[Hashable, dict] = dictionary[&#39;dims&#39;]
        extrapolations = {k: from_dict(ext) for k, ext in dims.items()}
        return _MixedExtrapolation(extrapolations)
    elif etype == &#39;normal-tangential&#39;:
        normal = from_dict(dictionary[&#39;normal&#39;])
        tangential = from_dict(dictionary[&#39;tangential&#39;])
        return _NormalTangentialExtrapolation(normal, tangential)
    elif etype == &#39;none&#39;:
        return NONE
    elif etype == &#39;undefined&#39;:
        derived_from = from_dict(dictionary[&#39;derived_from&#39;])
        return Undefined(derived_from)
    else:
        raise ValueError(dictionary)


def order_by_shape(shape: Shape, sequence, default=None) -&gt; Union[tuple, list]:
    &#34;&#34;&#34;
    If sequence is a dict with dimension names as keys, orders its values according to this shape.

    Otherwise, the sequence is returned unchanged.

    Args:
      sequence: Sequence or dict to be ordered
      default: default value used for dimensions not contained in sequence

    Returns:
      ordered sequence of values
    &#34;&#34;&#34;
    if isinstance(sequence, dict):
        result = [sequence.get(dim, default) for dim in shape.names]
        return result
    elif isinstance(sequence, (tuple, list)):
        assert len(sequence) == shape.rank
        return sequence
    else:  # just a constant
        return sequence


def map(f: Callable[[Extrapolation], Extrapolation], extrapolation):
    &#34;&#34;&#34;
    Applies a function to all leaf extrapolations in `extrapolation`.
    Non-leaves are those created by `combine_sides()` and `combine_by_direction()`.

    The tree will be collapsed if possible.

    Args:
        f: Function mapping a leaf `Extrapolation` to another `Extrapolation`.
        extrapolation: Input tree for `f`.

    Returns:
        `Extrapolation`
    &#34;&#34;&#34;
    if isinstance(extrapolation, _MixedExtrapolation):
        return combine_sides({k: map(f, ext) for k, ext in extrapolation.ext.items()})
    elif isinstance(extrapolation, _NormalTangentialExtrapolation):
        return combine_by_direction(map(f, extrapolation.normal), map(f, extrapolation.tangential))
    else:
        return f(extrapolation)


def remove_constant_offset(extrapolation):
    &#34;&#34;&#34;
    Removes all constant offsets from an extrapolation.
    This also includes `NaN` values in constants (unlike `ext - ext`).

    Args:
        extrapolation: `Extrapolation` object.

    Returns:
        `Extrapolation` that has no constant offsets
    &#34;&#34;&#34;
    def const_to_zero(extrapolation):
        if isinstance(extrapolation, ConstantExtrapolation):
            return ZERO
        else:
            return extrapolation
    return map(const_to_zero, extrapolation)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="phiml.math.extrapolation.ANTIREFLECT"><code class="name">var <span class="ident">ANTIREFLECT</span></code></dt>
<dd>
<div class="desc"><p>Like REFLECT but extends a grid with the negative value of the corresponding counterpart instead.</p></div>
</dd>
<dt id="phiml.math.extrapolation.ANTISYMMETRIC"><code class="name">var <span class="ident">ANTISYMMETRIC</span></code></dt>
<dd>
<div class="desc"><p>Like SYMMETRIC but extends a grid with the negative value of the corresponding counterpart instead.</p></div>
</dd>
<dt id="phiml.math.extrapolation.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<div class="desc"><p>Raises AssertionError when used to determine outside values. Padding operations will have no effect with this extrapolation.</p></div>
</dd>
<dt id="phiml.math.extrapolation.ONE"><code class="name">var <span class="ident">ONE</span></code></dt>
<dd>
<div class="desc"><p>Extrapolates with the constant value 1 (Dirichlet boundary condition).</p></div>
</dd>
<dt id="phiml.math.extrapolation.PERIODIC"><code class="name">var <span class="ident">PERIODIC</span></code></dt>
<dd>
<div class="desc"><p>Extends a grid by tiling it (Periodic boundary condition).</p></div>
</dd>
<dt id="phiml.math.extrapolation.REFLECT"><code class="name">var <span class="ident">REFLECT</span></code></dt>
<dd>
<div class="desc"><p>Like SYMMETRIC but the edge values are not copied and only occur once per seam.</p></div>
</dd>
<dt id="phiml.math.extrapolation.SYMMETRIC"><code class="name">var <span class="ident">SYMMETRIC</span></code></dt>
<dd>
<div class="desc"><p>Extends a grid by tiling it. Every other copy of the grid is flipped. Edge values occur twice per seam.</p></div>
</dd>
<dt id="phiml.math.extrapolation.SYMMETRIC_GRADIENT"><code class="name">var <span class="ident">SYMMETRIC_GRADIENT</span></code></dt>
<dd>
<div class="desc"><p>Extrapolates in a continuous manner. The normal component of the spatial gradient is symmetric at the boundaries. The outer-most valid difference is duplicated.</p></div>
</dd>
<dt id="phiml.math.extrapolation.ZERO"><code class="name">var <span class="ident">ZERO</span></code></dt>
<dd>
<div class="desc"><p>Extrapolates with the constant value 0 (Dirichlet boundary condition).</p></div>
</dd>
<dt id="phiml.math.extrapolation.ZERO_GRADIENT"><code class="name">var <span class="ident">ZERO_GRADIENT</span></code></dt>
<dd>
<div class="desc"><p>Extends a grid with its edge values (Neumann boundary condition). The value of a point lying outside the grid is determined by the closest grid value(s).</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phiml.math.extrapolation.as_extrapolation"><code class="name flex">
<span>def <span class="ident">as_extrapolation</span></span>(<span>obj) â€‘>Â <a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an <code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code> from a descriptor object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>
<p>Extrapolation specification, one of the following:</p>
<ul>
<li><code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code></li>
<li>Primitive name as <code>str</code>: periodic, zero, one, zero-gradient, symmetric, symmetric-gradient, antisymmetric, reflect, antireflect</li>
<li><code>dict</code> containing exactly the keys <code>'normal'</code> and <code>'tangential'</code></li>
<li><code>dict</code> mapping spatial dimension names to extrapolations</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_extrapolation(obj) -&gt; Extrapolation:
    &#34;&#34;&#34;
    Creates an `Extrapolation` from a descriptor object.

    Args:
        obj: Extrapolation specification, one of the following:

            * `Extrapolation`
            * Primitive name as `str`: periodic, zero, one, zero-gradient, symmetric, symmetric-gradient, antisymmetric, reflect, antireflect
            * `dict` containing exactly the keys `&#39;normal&#39;` and `&#39;tangential&#39;`
            * `dict` mapping spatial dimension names to extrapolations

    Returns:
        `Extrapolation`
    &#34;&#34;&#34;
    if isinstance(obj, Extrapolation):
        return obj
    if obj is None:
        return NONE
    if isinstance(obj, str):
        assert obj in _PRIMITIVES, f&#34;Unrecognized extrapolation type: &#39;{obj}&#39;&#34;
        return _PRIMITIVES[obj]
    if isinstance(obj, dict):
        if &#39;normal&#39; in obj or &#39;tangential&#39; in obj:
            assert &#39;normal&#39; in obj and &#39;tangential&#39; in obj, f&#34;Normal/tangential dict requires both entries &#39;normal&#39; and &#39;tangential&#39; but got {obj}&#34;
            assert len(obj) == 2, f&#34;Normal/tangential dict must only contain entries &#39;normal&#39; and &#39;tangential&#39; but got {obj}&#34;
            normal = as_extrapolation(obj[&#39;normal&#39;])
            tangential = as_extrapolation(obj[&#39;tangential&#39;])
            return combine_by_direction(normal=normal, tangential=tangential)
        else:
            ext = {dim: (as_extrapolation(spec[0]), as_extrapolation(spec[1])) if isinstance(spec, tuple) else as_extrapolation(spec) for dim, spec in obj.items()}
            return combine_sides(**ext)
    return ConstantExtrapolation(obj)</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.combine_by_direction"><code class="name flex">
<span>def <span class="ident">combine_by_direction</span></span>(<span>normal:Â Union[<a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a>,Â float,Â phiml.math._tensors.Tensor], tangential:Â Union[<a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a>,Â float,Â phiml.math._tensors.Tensor]) â€‘>Â <a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></span>
</code></dt>
<dd>
<div class="desc"><p>Use a different extrapolation for the normal component of vector-valued tensors.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>normal</code></strong></dt>
<dd>Extrapolation for the component that is orthogonal to the boundary.</dd>
<dt><strong><code>tangential</code></strong></dt>
<dd>Extrapolation for the component that is tangential to the boundary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_by_direction(normal: Union[Extrapolation, float, Tensor], tangential: Union[Extrapolation, float, Tensor]) -&gt; Extrapolation:
    &#34;&#34;&#34;
    Use a different extrapolation for the normal component of vector-valued tensors.

    Args:
        normal: Extrapolation for the component that is orthogonal to the boundary.
        tangential: Extrapolation for the component that is tangential to the boundary.

    Returns:
        `Extrapolation`
    &#34;&#34;&#34;
    normal = as_extrapolation(normal)
    tangential = as_extrapolation(tangential)
    return normal if normal == tangential else _NormalTangentialExtrapolation(normal, tangential)</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.combine_sides"><code class="name flex">
<span>def <span class="ident">combine_sides</span></span>(<span>boundary_dict:Â Dict[Hashable[],Â <a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a>]Â =Â None, **extrapolations:Â Union[<a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a>,Â tuple,Â numbers.Number]) â€‘>Â <a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></span>
</code></dt>
<dd>
<div class="desc"><p>Specify extrapolations for each side / face of a box.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>boundary_dict</code></strong></dt>
<dd>Extrapolations by hashable boundary key.</dd>
<dt><strong><code>**extrapolations</code></strong></dt>
<dd>map from dim: str -&gt; <code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code> or <code>tuple</code> (lower, upper)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_sides(boundary_dict: Dict[Hashable, Extrapolation] = None, **extrapolations: Union[Extrapolation, tuple, Number]) -&gt; Extrapolation:
    &#34;&#34;&#34;
    Specify extrapolations for each side / face of a box.

    Args:
        boundary_dict: Extrapolations by hashable boundary key.
        **extrapolations: map from dim: str -&gt; `Extrapolation` or `tuple` (lower, upper)

    Returns:
        `Extrapolation`
    &#34;&#34;&#34;
    boundary_dict = dict(boundary_dict) if boundary_dict is not None else {}
    for dim, ext in extrapolations.items():
        if isinstance(ext, tuple):
            assert len(ext) == 2, &#34;Tuple must contain exactly two elements, (lower, upper)&#34;
            lower = as_extrapolation(ext[0])
            upper = as_extrapolation(ext[1])
            boundary_dict[(dim, False)] = lower
            boundary_dict[(dim, True)] = upper
        else:
            boundary_dict[(dim, False)] = boundary_dict[(dim, True)] = as_extrapolation(ext)
    if len(set(boundary_dict.values())) == 1:  # All equal -&gt; return any
        return next(iter(boundary_dict.values()))
    else:
        return _MixedExtrapolation(boundary_dict)</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>dictionary:Â dict) â€‘>Â <a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></span>
</code></dt>
<dd>
<div class="desc"><p>Loads an <code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code> object from a dictionary that was created using <code><a title="phiml.math.extrapolation.Extrapolation.to_dict" href="#phiml.math.extrapolation.Extrapolation.to_dict">Extrapolation.to_dict()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dictionary</code></strong></dt>
<dd>serializable dictionary holding all extrapolation properties</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Loaded extrapolation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_dict(dictionary: dict) -&gt; Extrapolation:
    &#34;&#34;&#34;
    Loads an `Extrapolation` object from a dictionary that was created using `Extrapolation.to_dict()`.

    Args:
        dictionary: serializable dictionary holding all extrapolation properties

    Returns:
        Loaded extrapolation
    &#34;&#34;&#34;
    etype = dictionary[&#39;type&#39;]
    if etype in _PRIMITIVES:
        return _PRIMITIVES[etype]
    elif etype == &#39;constant&#39;:
        return ConstantExtrapolation(dictionary[&#39;value&#39;])
    elif etype == &#39;mixed&#39;:
        dims: Dict[Hashable, dict] = dictionary[&#39;dims&#39;]
        extrapolations = {k: from_dict(ext) for k, ext in dims.items()}
        return _MixedExtrapolation(extrapolations)
    elif etype == &#39;normal-tangential&#39;:
        normal = from_dict(dictionary[&#39;normal&#39;])
        tangential = from_dict(dictionary[&#39;tangential&#39;])
        return _NormalTangentialExtrapolation(normal, tangential)
    elif etype == &#39;none&#39;:
        return NONE
    elif etype == &#39;undefined&#39;:
        derived_from = from_dict(dictionary[&#39;derived_from&#39;])
        return Undefined(derived_from)
    else:
        raise ValueError(dictionary)</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>f:Â Callable[[<a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a>],Â <a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a>], extrapolation)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies a function to all leaf extrapolations in <code>extrapolation</code>.
Non-leaves are those created by <code><a title="phiml.math.extrapolation.combine_sides" href="#phiml.math.extrapolation.combine_sides">combine_sides()</a></code> and <code><a title="phiml.math.extrapolation.combine_by_direction" href="#phiml.math.extrapolation.combine_by_direction">combine_by_direction()</a></code>.</p>
<p>The tree will be collapsed if possible.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>Function mapping a leaf <code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code> to another <code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code>.</dd>
<dt><strong><code>extrapolation</code></strong></dt>
<dd>Input tree for <code>f</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(f: Callable[[Extrapolation], Extrapolation], extrapolation):
    &#34;&#34;&#34;
    Applies a function to all leaf extrapolations in `extrapolation`.
    Non-leaves are those created by `combine_sides()` and `combine_by_direction()`.

    The tree will be collapsed if possible.

    Args:
        f: Function mapping a leaf `Extrapolation` to another `Extrapolation`.
        extrapolation: Input tree for `f`.

    Returns:
        `Extrapolation`
    &#34;&#34;&#34;
    if isinstance(extrapolation, _MixedExtrapolation):
        return combine_sides({k: map(f, ext) for k, ext in extrapolation.ext.items()})
    elif isinstance(extrapolation, _NormalTangentialExtrapolation):
        return combine_by_direction(map(f, extrapolation.normal), map(f, extrapolation.tangential))
    else:
        return f(extrapolation)</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.order_by_shape"><code class="name flex">
<span>def <span class="ident">order_by_shape</span></span>(<span>shape:Â phiml.math._shape.Shape, sequence, default=None) â€‘>Â Union[tuple,Â list]</span>
</code></dt>
<dd>
<div class="desc"><p>If sequence is a dict with dimension names as keys, orders its values according to this shape.</p>
<p>Otherwise, the sequence is returned unchanged.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sequence</code></strong></dt>
<dd>Sequence or dict to be ordered</dd>
<dt><strong><code>default</code></strong></dt>
<dd>default value used for dimensions not contained in sequence</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ordered sequence of values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_by_shape(shape: Shape, sequence, default=None) -&gt; Union[tuple, list]:
    &#34;&#34;&#34;
    If sequence is a dict with dimension names as keys, orders its values according to this shape.

    Otherwise, the sequence is returned unchanged.

    Args:
      sequence: Sequence or dict to be ordered
      default: default value used for dimensions not contained in sequence

    Returns:
      ordered sequence of values
    &#34;&#34;&#34;
    if isinstance(sequence, dict):
        result = [sequence.get(dim, default) for dim in shape.names]
        return result
    elif isinstance(sequence, (tuple, list)):
        assert len(sequence) == shape.rank
        return sequence
    else:  # just a constant
        return sequence</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.remove_constant_offset"><code class="name flex">
<span>def <span class="ident">remove_constant_offset</span></span>(<span>extrapolation)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes all constant offsets from an extrapolation.
This also includes <code>NaN</code> values in constants (unlike <code>ext - ext</code>).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extrapolation</code></strong></dt>
<dd><code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code> object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code> that has no constant offsets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_constant_offset(extrapolation):
    &#34;&#34;&#34;
    Removes all constant offsets from an extrapolation.
    This also includes `NaN` values in constants (unlike `ext - ext`).

    Args:
        extrapolation: `Extrapolation` object.

    Returns:
        `Extrapolation` that has no constant offsets
    &#34;&#34;&#34;
    def const_to_zero(extrapolation):
        if isinstance(extrapolation, ConstantExtrapolation):
            return ZERO
        else:
            return extrapolation
    return map(const_to_zero, extrapolation)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phiml.math.extrapolation.ConstantExtrapolation"><code class="flex name class">
<span>class <span class="ident">ConstantExtrapolation</span></span>
<span>(</span><span>value:Â Union[float,Â phiml.math._tensors.Tensor])</span>
</code></dt>
<dd>
<div class="desc"><p>Extrapolate with a constant value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pad_rank</code></strong></dt>
<dd>low-ranking extrapolations are handled first during mixed-extrapolation padding.
The typical order is periodic=1, boundary=2, symmetric=3, reflect=4, constant=5.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstantExtrapolation(Extrapolation):
    &#34;&#34;&#34;
    Extrapolate with a constant value.
    &#34;&#34;&#34;

    def __init__(self, value: Union[Tensor, float]):
        Extrapolation.__init__(self, 5)
        self.value = wrap(value)
        &#34;&#34;&#34; Extrapolation value &#34;&#34;&#34;
        assert self.value.dtype.kind in (bool, int, float, complex), f&#34;Numeric value required for constant extrapolation but got &#39;{value}&#39;&#34;

    @property
    def shape(self):
        return self.value.shape

    def __repr__(self):
        return repr(self.value)

    def to_dict(self) -&gt; dict:
        return {&#39;type&#39;: &#39;constant&#39;, &#39;value&#39;: self.value.numpy()}

    def __value_attrs__(self):
        return &#39;value&#39;,

    def __getitem__(self, item):
        return ConstantExtrapolation(self.value[item])

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;ConstantExtrapolation&#39;:
        if all(isinstance(v, ConstantExtrapolation) for v in values):
            return ConstantExtrapolation(stack([v.value for v in values], dim, **kwargs))
        else:
            return NotImplemented

    def spatial_gradient(self):
        return ZERO

    def determines_boundary_values(self, boundary_key: Union[Tuple[str, bool], str]) -&gt; bool:
        return True

    @property
    def is_flexible(self) -&gt; bool:
        return False

    def pad(self, value: Tensor, widths: dict, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        &#34;&#34;&#34;Pads a tensor using constant values.&#34;&#34;&#34;
        value = value._simplify()
        if isinstance(value, NativeTensor):
            pad_value = self._get_pad_value(already_padded)
            backend = choose_backend(value._native, pad_value.native())
            for dim in pad_value.shape.non_batch.names:
                assert dim in value.shape, f&#34;Cannot pad tensor {value.shape} with extrapolation {pad_value.shape} because non-batch dimension &#39;{dim}&#39; is missing.&#34;
            if pad_value.rank == 0:
                equal_values = math.all_available(self.value, value) and value._native_shape in self.value.shape and (self.value == value).all
                if not equal_values:
                    required_dims = value._shape.only(tuple(widths.keys()))
                    value = value._cached(required_dims)
                should_pad_native = any(dim in value._native_shape for dim in widths) and pad_value.shape.volume == 1
                if should_pad_native:
                    ordered_pad_widths = order_by_shape(value._native_shape, widths, default=(0, 0))
                    result_native = backend.pad(value._native, ordered_pad_widths, &#39;constant&#39;, pad_value.native())
                else:
                    result_native = value._native
                if result_native is not NotImplemented:
                    return NativeTensor(result_native, value._native_shape.after_pad(widths), value._shape.after_pad(widths))
            return Extrapolation.pad(self, value, widths, already_padded=already_padded, **kwargs)
        elif isinstance(value, TensorStack):
            if not value.requires_broadcast:
                return self.pad(value._cache(), widths)
            inner_widths = {dim: w for dim, w in widths.items() if dim != value._stack_dim.name}
            tensors = [self[{value._stack_dim.name: i}].pad(t, inner_widths) for i, t in enumerate(value.dimension(value._stack_dim.name))]
            return TensorStack(tensors, value._stack_dim)
        else:
            return Extrapolation.pad(self, value, widths, already_padded=already_padded, **kwargs)

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        shape = value.shape.after_gather({dim: slice(0, width)})
        pad_value = self._get_pad_value(already_padded)
        return math.expand(pad_value, shape)

    def _get_pad_value(self, already_padded: Optional[dict]):
        if get_spatial_derivative_order() == 0:
            if already_padded:
                return ZERO.pad(self.value, already_padded)
            else:
                return self.value
        else:
            return math.wrap(0)

    def sparse_pad_values(self, value: Tensor, connectivity: Tensor, dim: str, upper_edge: bool, **kwargs) -&gt; Tensor:
        return math.expand(self.value, dual(connectivity) &amp; non_dual(value))

    def __eq__(self, other):
        return isinstance(other, ConstantExtrapolation) and math.always_close(self.value, other.value)

    def __hash__(self):
        return hash(self.__class__)

    def is_zero(self):
        return self == ZERO

    def is_one(self):
        return self == ONE

    @property
    def native_grid_sample_mode(self) -&gt; Union[str, None]:
        return &#39;zeros&#39; if self.is_zero() else None

    def __add__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value + other.value)
        elif self.is_zero():
            return other
        else:
            return NotImplemented

    __radd__ = __add__

    def __sub__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value - other.value)
        elif self.is_zero():
            return -other
        else:
            return NotImplemented

    def __rsub__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(other.value - self.value)
        elif self.is_zero():
            return other
        else:
            return NotImplemented

    def __mul__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value * other.value)
        elif self.is_one():
            return other
        elif self.is_zero():
            return self
        else:
            return NotImplemented

    __rmul__ = __mul__

    def __truediv__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value / other.value)
        elif self.is_zero():
            return self
        else:
            return NotImplemented

    def __rtruediv__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(other.value / self.value)
        elif self.is_one():
            return other
        else:
            return NotImplemented

    def __lt__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value &lt; other.value)
        else:
            return NotImplemented

    def __gt__(self, other):
        if isinstance(other, ConstantExtrapolation):
            return ConstantExtrapolation(self.value &gt; other.value)
        else:
            return NotImplemented

    def __abs__(self):
        return ConstantExtrapolation(abs(self.value))

    def __neg__(self):
        return ConstantExtrapolation(-self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phiml.math.extrapolation.ConstantExtrapolation.native_grid_sample_mode"><code class="name">var <span class="ident">native_grid_sample_mode</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def native_grid_sample_mode(self) -&gt; Union[str, None]:
    return &#39;zeros&#39; if self.is_zero() else None</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.ConstantExtrapolation.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self.value.shape</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.ConstantExtrapolation.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Extrapolation value</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phiml.math.extrapolation.ConstantExtrapolation.is_one"><code class="name flex">
<span>def <span class="ident">is_one</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_one(self):
    return self == ONE</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.ConstantExtrapolation.is_zero"><code class="name flex">
<span>def <span class="ident">is_zero</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_zero(self):
    return self == ZERO</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.ConstantExtrapolation.pad"><code class="name flex">
<span>def <span class="ident">pad</span></span>(<span>self, value:Â phiml.math._tensors.Tensor, widths:Â dict, already_padded:Â Optional[dict]Â =Â None, **kwargs) â€‘>Â phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Pads a tensor using constant values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad(self, value: Tensor, widths: dict, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
    &#34;&#34;&#34;Pads a tensor using constant values.&#34;&#34;&#34;
    value = value._simplify()
    if isinstance(value, NativeTensor):
        pad_value = self._get_pad_value(already_padded)
        backend = choose_backend(value._native, pad_value.native())
        for dim in pad_value.shape.non_batch.names:
            assert dim in value.shape, f&#34;Cannot pad tensor {value.shape} with extrapolation {pad_value.shape} because non-batch dimension &#39;{dim}&#39; is missing.&#34;
        if pad_value.rank == 0:
            equal_values = math.all_available(self.value, value) and value._native_shape in self.value.shape and (self.value == value).all
            if not equal_values:
                required_dims = value._shape.only(tuple(widths.keys()))
                value = value._cached(required_dims)
            should_pad_native = any(dim in value._native_shape for dim in widths) and pad_value.shape.volume == 1
            if should_pad_native:
                ordered_pad_widths = order_by_shape(value._native_shape, widths, default=(0, 0))
                result_native = backend.pad(value._native, ordered_pad_widths, &#39;constant&#39;, pad_value.native())
            else:
                result_native = value._native
            if result_native is not NotImplemented:
                return NativeTensor(result_native, value._native_shape.after_pad(widths), value._shape.after_pad(widths))
        return Extrapolation.pad(self, value, widths, already_padded=already_padded, **kwargs)
    elif isinstance(value, TensorStack):
        if not value.requires_broadcast:
            return self.pad(value._cache(), widths)
        inner_widths = {dim: w for dim, w in widths.items() if dim != value._stack_dim.name}
        tensors = [self[{value._stack_dim.name: i}].pad(t, inner_widths) for i, t in enumerate(value.dimension(value._stack_dim.name))]
        return TensorStack(tensors, value._stack_dim)
    else:
        return Extrapolation.pad(self, value, widths, already_padded=already_padded, **kwargs)</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.ConstantExtrapolation.sparse_pad_values"><code class="name flex">
<span>def <span class="ident">sparse_pad_values</span></span>(<span>self, value:Â phiml.math._tensors.Tensor, connectivity:Â phiml.math._tensors.Tensor, dim:Â str, upper_edge:Â bool, **kwargs) â€‘>Â phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sparse_pad_values(self, value: Tensor, connectivity: Tensor, dim: str, upper_edge: bool, **kwargs) -&gt; Tensor:
    return math.expand(self.value, dual(connectivity) &amp; non_dual(value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></b></code>:
<ul class="hlist">
<li><code><a title="phiml.math.extrapolation.Extrapolation.determines_boundary_values" href="#phiml.math.extrapolation.Extrapolation.determines_boundary_values">determines_boundary_values</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.is_copy_pad" href="#phiml.math.extrapolation.Extrapolation.is_copy_pad">is_copy_pad</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.is_flexible" href="#phiml.math.extrapolation.Extrapolation.is_flexible">is_flexible</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.pad_values" href="#phiml.math.extrapolation.Extrapolation.pad_values">pad_values</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.shortest_distance" href="#phiml.math.extrapolation.Extrapolation.shortest_distance">shortest_distance</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.spatial_gradient" href="#phiml.math.extrapolation.Extrapolation.spatial_gradient">spatial_gradient</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.to_dict" href="#phiml.math.extrapolation.Extrapolation.to_dict">to_dict</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.transform_coordinates" href="#phiml.math.extrapolation.Extrapolation.transform_coordinates">transform_coordinates</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.valid_outer_faces" href="#phiml.math.extrapolation.Extrapolation.valid_outer_faces">valid_outer_faces</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="phiml.math.extrapolation.Extrapolation"><code class="flex name class">
<span>class <span class="ident">Extrapolation</span></span>
<span>(</span><span>pad_rank)</span>
</code></dt>
<dd>
<div class="desc"><p>Extrapolations are used to determine values of grids or other structures outside the sampled bounds.
They play a vital role in padding and sampling.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pad_rank</code></strong></dt>
<dd>low-ranking extrapolations are handled first during mixed-extrapolation padding.
The typical order is periodic=1, boundary=2, symmetric=3, reflect=4, constant=5.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Extrapolation:
    &#34;&#34;&#34;
    Extrapolations are used to determine values of grids or other structures outside the sampled bounds.
    They play a vital role in padding and sampling.
    &#34;&#34;&#34;

    def __init__(self, pad_rank):
        &#34;&#34;&#34;
        Args:
            pad_rank: low-ranking extrapolations are handled first during mixed-extrapolation padding.
                The typical order is periodic=1, boundary=2, symmetric=3, reflect=4, constant=5.
        &#34;&#34;&#34;
        self.pad_rank = pad_rank

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        Serialize this extrapolation to a dictionary that is serializable (JSON-writable).
        
        Use `from_dict()` to restore the Extrapolation object.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def spatial_gradient(self) -&gt; &#39;Extrapolation&#39;:
        &#34;&#34;&#34;
        Returns the extrapolation for the spatial gradient of a tensor/field with this extrapolation.

        Returns:
            `Extrapolation` or `NotImplemented`
        &#34;&#34;&#34;
        raise NotImplementedError()

    def valid_outer_faces(self, dim) -&gt; Tuple[bool, bool]:
        &#34;&#34;&#34;
        Use `determines_boundary_values()` instead.

         `(lower: bool, upper: bool)` indicating whether the values sampled at the outer-most faces of a staggered grid with this extrapolation are valid, i.e. need to be stored and are not redundant. &#34;&#34;&#34;
        return not self.determines_boundary_values((dim, False)), not self.determines_boundary_values((dim, True))

    def determines_boundary_values(self, boundary_key: Union[Tuple[str, bool], str]) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether this extrapolation fully determines the values at the boundary faces of the outermost cells or elements.
        If so, the values need not be stored along with the inside values.

        Override this function instead of `valid_outer_faces()`.

        Args:
            boundary_key: Hashable object identifying the boundary, e.g. a `str` or `Tuple`.

        Returns:
            Whether the value is fully determined by the boundary and need not be stored elsewhere.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @property
    def is_flexible(self) -&gt; bool:
        &#34;&#34;&#34;
        Whether the outside values are affected by the inside values.
        Only `True` if there are actual outside values, i.e. PERIODIC is not flexible.

        This property is important for pressure solves to determine whether the total divergence is fixed or can be adjusted during the solve.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def pad(self, value: Tensor, widths: dict, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        &#34;&#34;&#34;
        Pads a tensor using values from `self.pad_values()`.

        If `value` is a linear tracer, assume pad_values() to produce constant values, independent of `value`.
        To change this behavior, override this method.

        Args:
            value: `Tensor` to be padded
            widths: `dict` mapping `dim: str -&gt; (lower: int, upper: int)`
            already_padded: Used when padding a tensor with multiple extrapolations.
                Contains all widths that have already been padded prior to this call.
                This causes the shape of `value` to be different from the original tensor passed to `math.pad()`.
            kwargs: Additional keyword arguments for padding, passed on to `pad_values()`.

        Returns:
            Padded `Tensor`
        &#34;&#34;&#34;
        from ._trace import ShiftLinTracer
        if isinstance(value, ShiftLinTracer):
            lower = {dim: -lo for dim, (lo, _) in widths.items()}
            return value.shift(lower, new_shape=value.shape.after_pad(widths), val_fun=lambda v: ZERO.pad(v, widths, already_padded=already_padded, **kwargs), bias_fun=lambda b: self.pad(b, widths, already_padded=already_padded, **kwargs))
        already_padded = {} if already_padded is None else dict(already_padded)
        for dim, width in widths.items():
            assert (w &gt; 0 for w in width), &#34;Negative widths not allowed in Extrapolation.pad(). Use math.pad() instead.&#34;
            values = []
            if width[False] &gt; 0:
                values.append(self.pad_values(value, width[False], dim, False, already_padded=already_padded, **kwargs))
            values.append(value)
            if width[True] &gt; 0:
                values.append(self.pad_values(value, width[True], dim, True, already_padded=already_padded, **kwargs))
            value = concat(values, dim)
            if dim in already_padded:
                already_padded[dim] = tuple(i+j for i, j in zip(already_padded[dim], width))
            else:
                already_padded[dim] = width
        return value

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        &#34;&#34;&#34;
        Determines the values with which the given tensor would be padded at the specified using this extrapolation.

        Args:
            value: `Tensor` to be padded.
            width: `int &gt; 0`: Number of cells to pad along `dimension`.
            dim: Dimension name as `str`.
            upper_edge: `True` for upper edge, `False` for lower edge.
            already_padded: Used when padding a tensor with multiple extrapolations.
                Contains all widths that have already been padded prior to this call.
                This causes the shape of `value` to be different from the original tensor passed to `math.pad()`.

        Returns:
            `Tensor` that can be concatenated to `value` along `dimension`
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def sparse_pad_values(self, value: Tensor, connectivity: Tensor, dim: str, upper_edge: bool, **kwargs) -&gt; Tensor:
        raise NotImplementedError(self.__class__)

    def transform_coordinates(self, coordinates: Tensor, shape: Shape, **kwargs) -&gt; Tensor:
        &#34;&#34;&#34;
        If `self.is_copy_pad`, transforms outside coordinates to the index from which the value is copied.
        
        Otherwise, the grid tensor is assumed to hold the correct boundary values for this extrapolation at the edge.
        Coordinates are then snapped to the valid index range.
        This is the default implementation.

        Args:
            coordinates: integer coordinates in index space
            shape: tensor shape

        Returns:
            Transformed coordinates
        &#34;&#34;&#34;
        res = shape.spatial[coordinates.shape.get_item_names(&#39;vector&#39;)] if &#39;vector&#39; in coordinates.shape and coordinates.shape.get_item_names(&#39;vector&#39;) else shape.spatial
        return math.clip(coordinates, 0, math.wrap(res - 1, channel(&#39;vector&#39;)))

    def is_copy_pad(self, dim: str, upper_edge: bool):
        &#34;&#34;&#34;:return: True if all pad values are copies of existing values in the tensor to be padded&#34;&#34;&#34;
        return False

    @property
    def native_grid_sample_mode(self) -&gt; Union[str, None]:
        return None

    def shortest_distance(self, start: Tensor, end: Tensor, domain_size: Tensor):
        &#34;&#34;&#34;
        Computes the shortest distance between two points.
        Both points are assumed to lie within the domain

        Args:
            start: Start position.
            end: End position.
            domain_size: Domain side lengths as vector.

        Returns:
            Shortest distance from `start` to `end`.
        &#34;&#34;&#34;
        return end - start

    def __getitem__(self, item):
        return self

    def _getitem_with_domain(self, item: dict, dim: str, upper_edge: bool, all_dims: Sequence[str]):
        return self[item]

    def __abs__(self):
        raise NotImplementedError(self.__class__)

    def __neg__(self):
        raise NotImplementedError(self.__class__)

    def __add__(self, other):
        raise NotImplementedError(self.__class__)

    def __radd__(self, other):
        raise NotImplementedError(self.__class__)

    def __sub__(self, other):
        raise NotImplementedError(self.__class__)

    def __rsub__(self, other):
        raise NotImplementedError(self.__class__)

    def __mul__(self, other):
        raise NotImplementedError(self.__class__)

    def __rmul__(self, other):
        raise NotImplementedError(self.__class__)

    def __truediv__(self, other):
        raise NotImplementedError(self.__class__)

    def __rtruediv__(self, other):
        raise NotImplementedError(self.__class__)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="phiml.math.extrapolation.ConstantExtrapolation" href="#phiml.math.extrapolation.ConstantExtrapolation">ConstantExtrapolation</a></li>
<li><a title="phiml.math.extrapolation.Undefined" href="#phiml.math.extrapolation.Undefined">Undefined</a></li>
<li>phiml.math.extrapolation._CopyExtrapolation</li>
<li>phiml.math.extrapolation._MixedExtrapolation</li>
<li>phiml.math.extrapolation._NoExtrapolation</li>
<li>phiml.math.extrapolation._NormalTangentialExtrapolation</li>
<li>phiml.math.extrapolation._SymmetricGradientExtrapolation</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phiml.math.extrapolation.Extrapolation.is_flexible"><code class="name">var <span class="ident">is_flexible</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Whether the outside values are affected by the inside values.
Only <code>True</code> if there are actual outside values, i.e. PERIODIC is not flexible.</p>
<p>This property is important for pressure solves to determine whether the total divergence is fixed or can be adjusted during the solve.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_flexible(self) -&gt; bool:
    &#34;&#34;&#34;
    Whether the outside values are affected by the inside values.
    Only `True` if there are actual outside values, i.e. PERIODIC is not flexible.

    This property is important for pressure solves to determine whether the total divergence is fixed or can be adjusted during the solve.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.Extrapolation.native_grid_sample_mode"><code class="name">var <span class="ident">native_grid_sample_mode</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def native_grid_sample_mode(self) -&gt; Union[str, None]:
    return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phiml.math.extrapolation.Extrapolation.determines_boundary_values"><code class="name flex">
<span>def <span class="ident">determines_boundary_values</span></span>(<span>self, boundary_key:Â Union[Tuple[str,Â bool],Â str]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether this extrapolation fully determines the values at the boundary faces of the outermost cells or elements.
If so, the values need not be stored along with the inside values.</p>
<p>Override this function instead of <code>valid_outer_faces()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>boundary_key</code></strong></dt>
<dd>Hashable object identifying the boundary, e.g. a <code>str</code> or <code>Tuple</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the value is fully determined by the boundary and need not be stored elsewhere.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determines_boundary_values(self, boundary_key: Union[Tuple[str, bool], str]) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether this extrapolation fully determines the values at the boundary faces of the outermost cells or elements.
    If so, the values need not be stored along with the inside values.

    Override this function instead of `valid_outer_faces()`.

    Args:
        boundary_key: Hashable object identifying the boundary, e.g. a `str` or `Tuple`.

    Returns:
        Whether the value is fully determined by the boundary and need not be stored elsewhere.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.Extrapolation.is_copy_pad"><code class="name flex">
<span>def <span class="ident">is_copy_pad</span></span>(<span>self, dim:Â str, upper_edge:Â bool)</span>
</code></dt>
<dd>
<div class="desc"><p>:return: True if all pad values are copies of existing values in the tensor to be padded</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_copy_pad(self, dim: str, upper_edge: bool):
    &#34;&#34;&#34;:return: True if all pad values are copies of existing values in the tensor to be padded&#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.Extrapolation.pad"><code class="name flex">
<span>def <span class="ident">pad</span></span>(<span>self, value:Â phiml.math._tensors.Tensor, widths:Â dict, already_padded:Â Optional[dict]Â =Â None, **kwargs) â€‘>Â phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Pads a tensor using values from <code>self.pad_values()</code>.</p>
<p>If <code>value</code> is a linear tracer, assume pad_values() to produce constant values, independent of <code>value</code>.
To change this behavior, override this method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd><code>Tensor</code> to be padded</dd>
<dt><strong><code>widths</code></strong></dt>
<dd><code>dict</code> mapping <code>dim: str -&gt; (lower: int, upper: int)</code></dd>
<dt><strong><code>already_padded</code></strong></dt>
<dd>Used when padding a tensor with multiple extrapolations.
Contains all widths that have already been padded prior to this call.
This causes the shape of <code>value</code> to be different from the original tensor passed to <code>math.pad()</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Additional keyword arguments for padding, passed on to <code>pad_values()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Padded <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad(self, value: Tensor, widths: dict, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
    &#34;&#34;&#34;
    Pads a tensor using values from `self.pad_values()`.

    If `value` is a linear tracer, assume pad_values() to produce constant values, independent of `value`.
    To change this behavior, override this method.

    Args:
        value: `Tensor` to be padded
        widths: `dict` mapping `dim: str -&gt; (lower: int, upper: int)`
        already_padded: Used when padding a tensor with multiple extrapolations.
            Contains all widths that have already been padded prior to this call.
            This causes the shape of `value` to be different from the original tensor passed to `math.pad()`.
        kwargs: Additional keyword arguments for padding, passed on to `pad_values()`.

    Returns:
        Padded `Tensor`
    &#34;&#34;&#34;
    from ._trace import ShiftLinTracer
    if isinstance(value, ShiftLinTracer):
        lower = {dim: -lo for dim, (lo, _) in widths.items()}
        return value.shift(lower, new_shape=value.shape.after_pad(widths), val_fun=lambda v: ZERO.pad(v, widths, already_padded=already_padded, **kwargs), bias_fun=lambda b: self.pad(b, widths, already_padded=already_padded, **kwargs))
    already_padded = {} if already_padded is None else dict(already_padded)
    for dim, width in widths.items():
        assert (w &gt; 0 for w in width), &#34;Negative widths not allowed in Extrapolation.pad(). Use math.pad() instead.&#34;
        values = []
        if width[False] &gt; 0:
            values.append(self.pad_values(value, width[False], dim, False, already_padded=already_padded, **kwargs))
        values.append(value)
        if width[True] &gt; 0:
            values.append(self.pad_values(value, width[True], dim, True, already_padded=already_padded, **kwargs))
        value = concat(values, dim)
        if dim in already_padded:
            already_padded[dim] = tuple(i+j for i, j in zip(already_padded[dim], width))
        else:
            already_padded[dim] = width
    return value</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.Extrapolation.pad_values"><code class="name flex">
<span>def <span class="ident">pad_values</span></span>(<span>self, value:Â phiml.math._tensors.Tensor, width:Â int, dim:Â str, upper_edge:Â bool, already_padded:Â Optional[dict]Â =Â None, **kwargs) â€‘>Â phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the values with which the given tensor would be padded at the specified using this extrapolation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd><code>Tensor</code> to be padded.</dd>
<dt><strong><code>width</code></strong></dt>
<dd><code>int &gt; 0</code>: Number of cells to pad along <code>dimension</code>.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Dimension name as <code>str</code>.</dd>
<dt><strong><code>upper_edge</code></strong></dt>
<dd><code>True</code> for upper edge, <code>False</code> for lower edge.</dd>
<dt><strong><code>already_padded</code></strong></dt>
<dd>Used when padding a tensor with multiple extrapolations.
Contains all widths that have already been padded prior to this call.
This causes the shape of <code>value</code> to be different from the original tensor passed to <code>math.pad()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> that can be concatenated to <code>value</code> along <code>dimension</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
    &#34;&#34;&#34;
    Determines the values with which the given tensor would be padded at the specified using this extrapolation.

    Args:
        value: `Tensor` to be padded.
        width: `int &gt; 0`: Number of cells to pad along `dimension`.
        dim: Dimension name as `str`.
        upper_edge: `True` for upper edge, `False` for lower edge.
        already_padded: Used when padding a tensor with multiple extrapolations.
            Contains all widths that have already been padded prior to this call.
            This causes the shape of `value` to be different from the original tensor passed to `math.pad()`.

    Returns:
        `Tensor` that can be concatenated to `value` along `dimension`
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.Extrapolation.shortest_distance"><code class="name flex">
<span>def <span class="ident">shortest_distance</span></span>(<span>self, start:Â phiml.math._tensors.Tensor, end:Â phiml.math._tensors.Tensor, domain_size:Â phiml.math._tensors.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the shortest distance between two points.
Both points are assumed to lie within the domain</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>Start position.</dd>
<dt><strong><code>end</code></strong></dt>
<dd>End position.</dd>
<dt><strong><code>domain_size</code></strong></dt>
<dd>Domain side lengths as vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Shortest distance from <code>start</code> to <code>end</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shortest_distance(self, start: Tensor, end: Tensor, domain_size: Tensor):
    &#34;&#34;&#34;
    Computes the shortest distance between two points.
    Both points are assumed to lie within the domain

    Args:
        start: Start position.
        end: End position.
        domain_size: Domain side lengths as vector.

    Returns:
        Shortest distance from `start` to `end`.
    &#34;&#34;&#34;
    return end - start</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.Extrapolation.sparse_pad_values"><code class="name flex">
<span>def <span class="ident">sparse_pad_values</span></span>(<span>self, value:Â phiml.math._tensors.Tensor, connectivity:Â phiml.math._tensors.Tensor, dim:Â str, upper_edge:Â bool, **kwargs) â€‘>Â phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sparse_pad_values(self, value: Tensor, connectivity: Tensor, dim: str, upper_edge: bool, **kwargs) -&gt; Tensor:
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.Extrapolation.spatial_gradient"><code class="name flex">
<span>def <span class="ident">spatial_gradient</span></span>(<span>self) â€‘>Â <a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the extrapolation for the spatial gradient of a tensor/field with this extrapolation.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code> or <code>NotImplemented</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spatial_gradient(self) -&gt; &#39;Extrapolation&#39;:
    &#34;&#34;&#34;
    Returns the extrapolation for the spatial gradient of a tensor/field with this extrapolation.

    Returns:
        `Extrapolation` or `NotImplemented`
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.Extrapolation.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize this extrapolation to a dictionary that is serializable (JSON-writable).</p>
<p>Use <code><a title="phiml.math.extrapolation.from_dict" href="#phiml.math.extrapolation.from_dict">from_dict()</a></code> to restore the Extrapolation object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    Serialize this extrapolation to a dictionary that is serializable (JSON-writable).
    
    Use `from_dict()` to restore the Extrapolation object.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.Extrapolation.transform_coordinates"><code class="name flex">
<span>def <span class="ident">transform_coordinates</span></span>(<span>self, coordinates:Â phiml.math._tensors.Tensor, shape:Â phiml.math._shape.Shape, **kwargs) â€‘>Â phiml.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>If <code>self.is_copy_pad</code>, transforms outside coordinates to the index from which the value is copied.</p>
<p>Otherwise, the grid tensor is assumed to hold the correct boundary values for this extrapolation at the edge.
Coordinates are then snapped to the valid index range.
This is the default implementation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coordinates</code></strong></dt>
<dd>integer coordinates in index space</dd>
<dt><strong><code>shape</code></strong></dt>
<dd>tensor shape</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Transformed coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_coordinates(self, coordinates: Tensor, shape: Shape, **kwargs) -&gt; Tensor:
    &#34;&#34;&#34;
    If `self.is_copy_pad`, transforms outside coordinates to the index from which the value is copied.
    
    Otherwise, the grid tensor is assumed to hold the correct boundary values for this extrapolation at the edge.
    Coordinates are then snapped to the valid index range.
    This is the default implementation.

    Args:
        coordinates: integer coordinates in index space
        shape: tensor shape

    Returns:
        Transformed coordinates
    &#34;&#34;&#34;
    res = shape.spatial[coordinates.shape.get_item_names(&#39;vector&#39;)] if &#39;vector&#39; in coordinates.shape and coordinates.shape.get_item_names(&#39;vector&#39;) else shape.spatial
    return math.clip(coordinates, 0, math.wrap(res - 1, channel(&#39;vector&#39;)))</code></pre>
</details>
</dd>
<dt id="phiml.math.extrapolation.Extrapolation.valid_outer_faces"><code class="name flex">
<span>def <span class="ident">valid_outer_faces</span></span>(<span>self, dim) â€‘>Â Tuple[bool,Â bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Use <code>determines_boundary_values()</code> instead.</p>
<p><code>(lower: bool, upper: bool)</code> indicating whether the values sampled at the outer-most faces of a staggered grid with this extrapolation are valid, i.e. need to be stored and are not redundant.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valid_outer_faces(self, dim) -&gt; Tuple[bool, bool]:
    &#34;&#34;&#34;
    Use `determines_boundary_values()` instead.

     `(lower: bool, upper: bool)` indicating whether the values sampled at the outer-most faces of a staggered grid with this extrapolation are valid, i.e. need to be stored and are not redundant. &#34;&#34;&#34;
    return not self.determines_boundary_values((dim, False)), not self.determines_boundary_values((dim, True))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phiml.math.extrapolation.Undefined"><code class="flex name class">
<span>class <span class="ident">Undefined</span></span>
<span>(</span><span>derived_from:Â <a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The extrapolation is unknown and must be replaced before usage.
Any access to outside values will raise an AssertionError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pad_rank</code></strong></dt>
<dd>low-ranking extrapolations are handled first during mixed-extrapolation padding.
The typical order is periodic=1, boundary=2, symmetric=3, reflect=4, constant=5.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Undefined(Extrapolation):
    &#34;&#34;&#34;
    The extrapolation is unknown and must be replaced before usage.
    Any access to outside values will raise an AssertionError.
    &#34;&#34;&#34;

    def __init__(self, derived_from: Extrapolation):
        super().__init__(-1)
        self.derived_from = derived_from

    @property
    def shape(self):
        return EMPTY_SHAPE

    def to_dict(self) -&gt; dict:
        return {&#39;type&#39;: &#39;undefined&#39;, &#39;derived_from&#39;: self.derived_from.to_dict()}

    def pad(self, value: Tensor, widths: dict, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        for (lo, up) in widths.items():
            assert lo == 0 and up == 0, &#34;Undefined extrapolation&#34;
        return value

    def spatial_gradient(self) -&gt; &#39;Extrapolation&#39;:
        return self

    def determines_boundary_values(self, boundary_key: Union[Tuple[str, bool], str]) -&gt; bool:
        return self.derived_from.determines_boundary_values(boundary_key)

    @property
    def is_flexible(self) -&gt; bool:
        raise AssertionError(&#34;Undefined extrapolation&#34;)

    def pad_values(self, value: Tensor, width: int, dim: str, upper_edge: bool, already_padded: Optional[dict] = None, **kwargs) -&gt; Tensor:
        raise AssertionError(&#34;Undefined extrapolation&#34;)

    def __repr__(self):
        return &#34;undefined&#34;

    def __abs__(self):
        return self

    def __neg__(self):
        return self

    def __add__(self, other):
        return self

    def __radd__(self, other):
        return self

    def __sub__(self, other):
        return self

    def __rsub__(self, other):
        return self

    def __mul__(self, other):
        return self

    def __rmul__(self, other):
        return self

    def __truediv__(self, other):
        return self

    def __rtruediv__(self, other):
        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phiml.math.extrapolation.Undefined.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return EMPTY_SHAPE</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></b></code>:
<ul class="hlist">
<li><code><a title="phiml.math.extrapolation.Extrapolation.determines_boundary_values" href="#phiml.math.extrapolation.Extrapolation.determines_boundary_values">determines_boundary_values</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.is_copy_pad" href="#phiml.math.extrapolation.Extrapolation.is_copy_pad">is_copy_pad</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.is_flexible" href="#phiml.math.extrapolation.Extrapolation.is_flexible">is_flexible</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.pad" href="#phiml.math.extrapolation.Extrapolation.pad">pad</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.pad_values" href="#phiml.math.extrapolation.Extrapolation.pad_values">pad_values</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.shortest_distance" href="#phiml.math.extrapolation.Extrapolation.shortest_distance">shortest_distance</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.spatial_gradient" href="#phiml.math.extrapolation.Extrapolation.spatial_gradient">spatial_gradient</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.to_dict" href="#phiml.math.extrapolation.Extrapolation.to_dict">to_dict</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.transform_coordinates" href="#phiml.math.extrapolation.Extrapolation.transform_coordinates">transform_coordinates</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.valid_outer_faces" href="#phiml.math.extrapolation.Extrapolation.valid_outer_faces">valid_outer_faces</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phiml.math" href="index.html">phiml.math</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="two-column">
<li><code><a title="phiml.math.extrapolation.ANTIREFLECT" href="#phiml.math.extrapolation.ANTIREFLECT">ANTIREFLECT</a></code></li>
<li><code><a title="phiml.math.extrapolation.ANTISYMMETRIC" href="#phiml.math.extrapolation.ANTISYMMETRIC">ANTISYMMETRIC</a></code></li>
<li><code><a title="phiml.math.extrapolation.NONE" href="#phiml.math.extrapolation.NONE">NONE</a></code></li>
<li><code><a title="phiml.math.extrapolation.ONE" href="#phiml.math.extrapolation.ONE">ONE</a></code></li>
<li><code><a title="phiml.math.extrapolation.PERIODIC" href="#phiml.math.extrapolation.PERIODIC">PERIODIC</a></code></li>
<li><code><a title="phiml.math.extrapolation.REFLECT" href="#phiml.math.extrapolation.REFLECT">REFLECT</a></code></li>
<li><code><a title="phiml.math.extrapolation.SYMMETRIC" href="#phiml.math.extrapolation.SYMMETRIC">SYMMETRIC</a></code></li>
<li><code><a title="phiml.math.extrapolation.SYMMETRIC_GRADIENT" href="#phiml.math.extrapolation.SYMMETRIC_GRADIENT">SYMMETRIC_GRADIENT</a></code></li>
<li><code><a title="phiml.math.extrapolation.ZERO" href="#phiml.math.extrapolation.ZERO">ZERO</a></code></li>
<li><code><a title="phiml.math.extrapolation.ZERO_GRADIENT" href="#phiml.math.extrapolation.ZERO_GRADIENT">ZERO_GRADIENT</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="phiml.math.extrapolation.as_extrapolation" href="#phiml.math.extrapolation.as_extrapolation">as_extrapolation</a></code></li>
<li><code><a title="phiml.math.extrapolation.combine_by_direction" href="#phiml.math.extrapolation.combine_by_direction">combine_by_direction</a></code></li>
<li><code><a title="phiml.math.extrapolation.combine_sides" href="#phiml.math.extrapolation.combine_sides">combine_sides</a></code></li>
<li><code><a title="phiml.math.extrapolation.from_dict" href="#phiml.math.extrapolation.from_dict">from_dict</a></code></li>
<li><code><a title="phiml.math.extrapolation.map" href="#phiml.math.extrapolation.map">map</a></code></li>
<li><code><a title="phiml.math.extrapolation.order_by_shape" href="#phiml.math.extrapolation.order_by_shape">order_by_shape</a></code></li>
<li><code><a title="phiml.math.extrapolation.remove_constant_offset" href="#phiml.math.extrapolation.remove_constant_offset">remove_constant_offset</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phiml.math.extrapolation.ConstantExtrapolation" href="#phiml.math.extrapolation.ConstantExtrapolation">ConstantExtrapolation</a></code></h4>
<ul class="">
<li><code><a title="phiml.math.extrapolation.ConstantExtrapolation.is_one" href="#phiml.math.extrapolation.ConstantExtrapolation.is_one">is_one</a></code></li>
<li><code><a title="phiml.math.extrapolation.ConstantExtrapolation.is_zero" href="#phiml.math.extrapolation.ConstantExtrapolation.is_zero">is_zero</a></code></li>
<li><code><a title="phiml.math.extrapolation.ConstantExtrapolation.native_grid_sample_mode" href="#phiml.math.extrapolation.ConstantExtrapolation.native_grid_sample_mode">native_grid_sample_mode</a></code></li>
<li><code><a title="phiml.math.extrapolation.ConstantExtrapolation.pad" href="#phiml.math.extrapolation.ConstantExtrapolation.pad">pad</a></code></li>
<li><code><a title="phiml.math.extrapolation.ConstantExtrapolation.shape" href="#phiml.math.extrapolation.ConstantExtrapolation.shape">shape</a></code></li>
<li><code><a title="phiml.math.extrapolation.ConstantExtrapolation.sparse_pad_values" href="#phiml.math.extrapolation.ConstantExtrapolation.sparse_pad_values">sparse_pad_values</a></code></li>
<li><code><a title="phiml.math.extrapolation.ConstantExtrapolation.value" href="#phiml.math.extrapolation.ConstantExtrapolation.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phiml.math.extrapolation.Extrapolation" href="#phiml.math.extrapolation.Extrapolation">Extrapolation</a></code></h4>
<ul class="">
<li><code><a title="phiml.math.extrapolation.Extrapolation.determines_boundary_values" href="#phiml.math.extrapolation.Extrapolation.determines_boundary_values">determines_boundary_values</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.is_copy_pad" href="#phiml.math.extrapolation.Extrapolation.is_copy_pad">is_copy_pad</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.is_flexible" href="#phiml.math.extrapolation.Extrapolation.is_flexible">is_flexible</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.native_grid_sample_mode" href="#phiml.math.extrapolation.Extrapolation.native_grid_sample_mode">native_grid_sample_mode</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.pad" href="#phiml.math.extrapolation.Extrapolation.pad">pad</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.pad_values" href="#phiml.math.extrapolation.Extrapolation.pad_values">pad_values</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.shortest_distance" href="#phiml.math.extrapolation.Extrapolation.shortest_distance">shortest_distance</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.sparse_pad_values" href="#phiml.math.extrapolation.Extrapolation.sparse_pad_values">sparse_pad_values</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.spatial_gradient" href="#phiml.math.extrapolation.Extrapolation.spatial_gradient">spatial_gradient</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.to_dict" href="#phiml.math.extrapolation.Extrapolation.to_dict">to_dict</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.transform_coordinates" href="#phiml.math.extrapolation.Extrapolation.transform_coordinates">transform_coordinates</a></code></li>
<li><code><a title="phiml.math.extrapolation.Extrapolation.valid_outer_faces" href="#phiml.math.extrapolation.Extrapolation.valid_outer_faces">valid_outer_faces</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phiml.math.extrapolation.Undefined" href="#phiml.math.extrapolation.Undefined">Undefined</a></code></h4>
<ul class="">
<li><code><a title="phiml.math.extrapolation.Undefined.shape" href="#phiml.math.extrapolation.Undefined.shape">shape</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>